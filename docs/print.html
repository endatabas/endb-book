<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Endatabas Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">1.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/quickstart.html"><strong aria-hidden="true">1.1.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="tutorial/try_it.html"><strong aria-hidden="true">1.2.</strong> Try It!</a></li><li class="chapter-item expanded "><a href="tutorial/sql_basics.html"><strong aria-hidden="true">1.3.</strong> Endb SQL Basics</a></li></ol></li><li class="chapter-item expanded "><a href="sql/index.html"><strong aria-hidden="true">2.</strong> SQL Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sql/intention.html"><strong aria-hidden="true">2.1.</strong> Intention</a></li><li class="chapter-item expanded "><a href="sql/data_manipulation.html"><strong aria-hidden="true">2.2.</strong> Data Manipulation</a></li><li class="chapter-item expanded "><a href="sql/queries.html"><strong aria-hidden="true">2.3.</strong> Queries</a></li><li class="chapter-item expanded "><a href="sql/data_types.html"><strong aria-hidden="true">2.4.</strong> SQL Data Types</a></li><li class="chapter-item expanded "><a href="sql/operators.html"><strong aria-hidden="true">2.5.</strong> Operators</a></li><li class="chapter-item expanded "><a href="sql/functions.html"><strong aria-hidden="true">2.6.</strong> Functions</a></li><li class="chapter-item expanded "><a href="sql/time_queries.html"><strong aria-hidden="true">2.7.</strong> Time Queries</a></li><li class="chapter-item expanded "><a href="sql/path_navigation.html"><strong aria-hidden="true">2.8.</strong> Path Navigation</a></li><li class="chapter-item expanded "><a href="sql/schema.html"><strong aria-hidden="true">2.9.</strong> Schema</a></li><li class="chapter-item expanded "><a href="sql/views.html"><strong aria-hidden="true">2.10.</strong> Views</a></li><li class="chapter-item expanded "><a href="sql/assertions.html"><strong aria-hidden="true">2.11.</strong> Assertions</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">3.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/installation.html"><strong aria-hidden="true">3.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="reference/operation.html"><strong aria-hidden="true">3.2.</strong> Operation</a></li><li class="chapter-item expanded "><a href="reference/monitoring.html"><strong aria-hidden="true">3.3.</strong> Monitoring</a></li><li class="chapter-item expanded "><a href="reference/http_api.html"><strong aria-hidden="true">3.4.</strong> HTTP API</a></li><li class="chapter-item expanded "><a href="reference/data_types.html"><strong aria-hidden="true">3.5.</strong> Data Types</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">4.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/what.html"><strong aria-hidden="true">4.1.</strong> What?</a></li><li class="chapter-item expanded "><a href="appendix/why.html"><strong aria-hidden="true">4.2.</strong> Why?</a></li><li class="chapter-item expanded "><a href="appendix/architecture.html"><strong aria-hidden="true">4.3.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="appendix/roadmap.html"><strong aria-hidden="true">4.4.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="appendix/license.html"><strong aria-hidden="true">4.5.</strong> License</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Endatabas Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/endatabas/endb-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to Endatabas!</p>
<p>Endatabas is a SQL document database with complete history.
It will store anything, forever.</p>
<p>The best way to understand Endatabas is to use it.
Head on over to the <a href="tutorial/quickstart.html">Quickstart</a> to try it out.</p>
<p>If you're not ready to run your first query yet,
there's plenty of explanatory material in our
<a href="appendix/what.html"><em>What?</em></a> and
<a href="appendix/why.html"><em>Why?</em></a> documents.</p>
<h2 id="elsewhere"><a class="header" href="#elsewhere">Elsewhere</a></h2>
<p>If you came to the Endatabas book directly, you may also be interested in:</p>
<ul>
<li><a href="https://www.endatabas.com">www.endatabas.com</a></li>
<li><a href="https://github.com/endatabas/endb">github.com/endatabas/endb</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>This quick tutorial intends to walk you through the core aspects of Endb.
By the end, you will have <code>endb</code> installed and you will have used it to
learn some of what it can do.</p>
<ul>
<li><a href="tutorial/quickstart.html">Quickstart</a></li>
<li><a href="tutorial/try_it.html">Try It!</a></li>
<li><a href="tutorial/sql_basics.html">Endb SQL Basics</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<h2 id="install-endb"><a class="header" href="#install-endb">Install Endb</a></h2>
<pre><code class="language-sh">mkdir -p endb_data
docker pull endatabas/endb
docker run --rm -p 3803:3803 -v endb_data:/app/endb_data docker.io/endatabas/endb
</code></pre>
<p>See <a href="tutorial/../reference/installation.html">Installation</a> for more ways to install
and build <code>endb</code>.</p>
<h2 id="run-your-first-query"><a class="header" href="#run-your-first-query">Run your first query</a></h2>
<pre><code class="language-sh">curl -d &quot;SELECT 'Hello World';&quot; -H &quot;Content-Type: application/sql&quot; -X POST http://localhost:3803/sql
</code></pre>
<h2 id="warning-early-alpha"><a class="header" href="#warning-early-alpha">Warning: Early Alpha</a></h2>
<p>Endb is still in early alpha.</p>
<p>While in alpha, new versions are not guaranteed to have binary-compatible storage with previous versions.
We encourage you to experiment with Endb but please do not use it in production until a General Availability release.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="try-it"><a class="header" href="#try-it">Try It!</a></h1>
<p>You can send SQL statements to <code>endb</code> over HTTP.
Any HTTP client will do.</p>
<h2 id="curl"><a class="header" href="#curl">curl</a></h2>
<p>Our first couple examples will use <a href="https://everything.curl.dev/get">curl</a>,
which you probably already have installed.</p>
<pre><code class="language-sh">curl -d &quot;INSERT INTO users (name) VALUES ('Tianyu')&quot; -H &quot;Content-Type: application/sql&quot; -X POST http://localhost:3803/sql
curl -d &quot;SELECT * FROM users&quot; -H &quot;Content-Type: application/sql&quot; -X POST http://localhost:3803/sql
</code></pre>
<p>Read more in the <a href="tutorial/../reference/http_api.html">full HTTP API docs</a>.</p>
<h2 id="example-libraries"><a class="header" href="#example-libraries">Example Libraries</a></h2>
<p>Ultimately, Endb will ship with permissively-licensed client libraries for all major languages.
For now, we have provided some example code you can try:</p>
<p><a href="https://github.com/endatabas/endb/tree/main/examples">https://github.com/endatabas/endb/tree/main/examples</a></p>
<h2 id="example-console"><a class="header" href="#example-console">Example Console</a></h2>
<p>Endb does not yet provide an official SQL console.
However, you can try Endb SQL (without writing any code) with the example terminal:</p>
<pre><code class="language-sh">git clone git@github.com:endatabas/endb.git
cd endb/examples
./endb_console.py
</code></pre>
<p>This example console wraps the Python example library.
Assuming you inserted a user with curl above, you can query that table directly:</p>
<pre><code class="language-sh">-&gt; SELECT * FROM users;
</code></pre>
<p>You can use any of these tools (or any other HTTP client you prefer) for the rest of this tutorial.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="endb-sql-basics"><a class="header" href="#endb-sql-basics">Endb SQL Basics</a></h1>
<p>If you know SQL, Endb SQL will feel instantly familiar.
It is not &quot;SQL-like&quot;. It <em>is</em> SQL.
However, Endb SQL is <em>dynamic</em>, <em>strongly-typed</em>, <em>time-aware</em>, and <em>shuns language embedding</em>.
Hopefully it is pleasant to use without feeling foreign.</p>
<h2 id="just-begin"><a class="header" href="#just-begin">Just Begin</a></h2>
<p>Endb is a schemaless document database.
You do not need <code>CREATE TABLE</code> — tables are dynamically created when you insert data.
The following SQL is valid as soon as you start <code>endb</code>:</p>
<pre><code class="language-SQL">INSERT INTO posts (id, user_id, text) VALUES (123, 456, 'Hello World');

SELECT * from posts;
</code></pre>
<h2 id="immutable"><a class="header" href="#immutable">Immutable</a></h2>
<p>Endb is immutable, so it does not permit destructive <code>UPDATE</code> or <code>DELETE</code>.
For example, if you run an <code>UPDATE</code>, your previous <code>INSERT</code> isn't lost.
Before we update the record, we'll make note of the current time, according to the database.
(Any time after the <code>INSERT</code> and before the <code>UPDATE</code> would suffice.)</p>
<pre><code class="language-SQL">SELECT CURRENT_TIMESTAMP;
-- for the sake of example, let's say this returns 2023-08-17T00:00:00

UPDATE posts SET text = 'Hello Immutable World' WHERE id = 123;

SELECT * from posts;
</code></pre>
<p>You'll note that <code>Hello World</code> from your original insert isn't visible.
That's because it only exists in the past and, by default, <code>SELECT</code> will show the state of the database <em>as of now</em>.</p>
<p>To see the old version, you can time-travel back to a time when the old record was visible:</p>
<pre><code class="language-SQL">SELECT * from posts FOR SYSTEM_TIME AS OF 2023-08-17T00:00:00;
</code></pre>
<p>NOTE: Although there is no <code>DELETE</code> in the traditional sense, there is <code>ERASE</code>,
which exists to remove data for user safety and compliance with laws like GDPR.</p>
<h2 id="dynamic-joins"><a class="header" href="#dynamic-joins">Dynamic Joins</a></h2>
<p>Relationships are also dynamic.
You can join any two tables on any two columns.
Adding a user with id <code>456</code> allows a join with the previous <code>posts</code> table.</p>
<pre><code class="language-SQL">INSERT INTO users (id, name) VALUES (456, 'Vikram');

SELECT * from posts p JOIN users u ON p.user_id = u.id;
</code></pre>
<h2 id="semi-structured-data"><a class="header" href="#semi-structured-data">Semi-Structured Data</a></h2>
<p>Endb allows you to insert asymmetrical, jagged data.
Let's add another user with more columns.</p>
<pre><code class="language-SQL">INSERT INTO users (id, name, email) VALUES (789, 'Daniela', 'daniela@endatabas.com');

SELECT * from users;
</code></pre>
<p>Note that the <code>SELECT *</code> is an implicitly dynamic query.
It doesn't have any difficulty with the previous <code>user</code> document, even though it lacked an <code>email</code> column.</p>
<h2 id="data-migration"><a class="header" href="#data-migration">Data &quot;Migration&quot;</a></h2>
<p>It may seem strange to leave jagged columns lying around.
Endb doesn't discourage you from cleaning up your data, if you can:</p>
<pre><code class="language-SQL">UPDATE users SET email = 'vikram@stockholm.se' WHERE name = 'Vikram';

SELECT * from users;
</code></pre>
<p>The difference in Endb is that we haven't &quot;migrated&quot; the old data — it's still there.
If you query for Vikram's <code>user</code> document as of 2 minutes ago, you will see the old record without an <code>email</code>.
Queries in Endb always default to <em>as-of-now</em>, which is why the results of the query above shouldn't be surprising.</p>
<h2 id="nested-data"><a class="header" href="#nested-data">Nested Data</a></h2>
<p>Endb eschews <a href="https://www.postgresql.org/docs/current/datatype-json.html">nested json</a>
in favour of a native, strongly-typed, document-relational model.</p>
<pre><code class="language-SQL">INSERT INTO users (id, name, friends) VALUES (123, 'Anastasia', [{name: 'Heikki', country: 'Finland'},{name: 'Amit', country: 'Japan'}]);

SELECT users.friends[1] FROM users WHERE id = 123;
</code></pre>
<p>The <code>users.friends[1]</code> expression above is one of many path expressions inspired by
<a href="https://datatracker.ietf.org/doc/draft-ietf-jsonpath-base/">JSONPath</a>,
<a href="https://www.iso.org/standard/78937.html">SQL/JSON</a>,
and their derivatives in legacy relational databases.
A detailed explanation of Endb's arrays and objects is provided in the
<a href="tutorial/../sql/path_navigation.html">SQL Reference</a></p>
<h2 id="documents"><a class="header" href="#documents">Documents</a></h2>
<p>Because of Endb's native document-relational model, rows are documents and vice-versa.
You can use an <code>INSERT</code> statement to add a document directly to the database:</p>
<pre><code class="language-SQL">INSERT INTO users {id: 890, name: 'Aaron', friends: [{name: 'Jeff', country: 'Canada'},{name: 'Kaia', country: 'Japan'}]};
</code></pre>
<h2 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h2>
<p>Endb will always do its best to provide you with meaningful error messages that point you to a solution:</p>
<pre><code class="language-sql">SELECT * FROM im_not_here;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-reference"><a class="header" href="#sql-reference">SQL Reference</a></h1>
<p>The SQL Reference contains details and edge cases about Endb SQL.</p>
<p>NOTE: The Endb SQL dialect is under active development.
While most major features of Endb SQL are stable, some more esoteric
features (<code>MATCH</code>, path navigation, etc.) may experience naming and
semantics changes before Endb 1.0 is released.</p>
<ul>
<li><a href="sql/intention.html">Intention</a></li>
<li><a href="sql/data_manipulation.html">Data Manipulation</a></li>
<li><a href="sql/queries.html">Queries</a></li>
<li><a href="sql/data_types.html">SQL Data Types</a></li>
<li><a href="sql/operators.html">Operators</a></li>
<li><a href="sql/functions.html">Functions</a></li>
<li><a href="sql/time_queries.html">Time Queries</a></li>
<li><a href="sql/path_navigation.html">Path Navigation</a></li>
<li><a href="sql/schema.html">Schema</a></li>
<li><a href="sql/views.html">Views</a></li>
<li><a href="sql/assertions.html">Assertions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intention"><a class="header" href="#intention">Intention</a></h1>
<p>The goal of Endb's SQL dialect is to be small, coherent, and powerful.
The SQL specification is massive, with pages ordering in the thousands.
Rather than implement the entire SQL specification from scratch (a gargantuan task)
or mimic the SQL dialect of another database, Endb chooses a tiny core
and builds powerful, composable features on top of that.</p>
<p>This tiny core draws inspiration from many sources, but
<a href="https://www.sqlite.org/">SQLite</a> in particular.
If SQLite supports a particular operator or function, Endb SQL also tries to.</p>
<p>Endb SQL also draws strong inspiration from the
<a href="https://www.iso.org/standard/76583.html">SQL specification</a> itself
(and its <a href="https://en.wikipedia.org/wiki/SQL#Standardization_history">predecessors</a>)
and from <a href="https://www.postgresql.org/">PostgreSQL</a>.
Endb SQL's nested data is also heavily inspired by
<a href="https://datatracker.ietf.org/doc/draft-ietf-jsonpath-base/">JSONPath</a>,
<a href="https://www.iso.org/standard/78937.html">SQL/JSON</a>,
and their derivatives found in major SQL databases.</p>
<p>Light inspiration is drawn from
<a href="https://partiql.org/">PartiQL</a>,
<a href="https://www.couchbase.com/sqlplusplus/">SQL++</a>, and
<a href="https://www.w3.org/TR/xquery-30/">XQuery</a>.</p>
<p>For more information on Endb's influences, please see
<a href="https://www.endatabas.com/bibliography.html">our bibliography</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-manipulation"><a class="header" href="#data-manipulation">Data Manipulation</a></h1>
<p>Creating, updating, and deleting data in Endb is done using standard SQL Data Manipulation Language (DML).
Endb is also immutable and schemaless,
so it contains a number of shorthands and document-oriented conveniences.</p>
<p>Endb does not require any Data Definition Language (DDL), such as <code>CREATE TABLE</code>.</p>
<h2 id="insert"><a class="header" href="#insert">INSERT</a></h2>
<p>To create a new document, you can use the standard SQL <code>INSERT</code> command.</p>
<pre><code class="language-sql">INSERT INTO products (product_no, name, price) VALUES (1, 'Tofu', 7.99);
</code></pre>
<p>To create multiple new documents at once, delimit their value lists with commas:</p>
<pre><code class="language-sql">INSERT INTO products (product_no, name, price) VALUES (1, 'Butter', 5.99), (2, 'Margarine', 4.99);
</code></pre>
<p>It is also possible to insert a document directly using an
<a href="sql/data_types.html#object"><code>OBJECT</code> literal</a>.</p>
<pre><code class="language-sql">INSERT INTO products {product_no: 3, name: 'Tea', price: 3.99};
</code></pre>
<p>To insert multiple documents directly, delimit documents with commas:</p>
<pre><code class="language-sql">INSERT INTO products {name: 'Coffee', price: 3.99}, {name: 'Croissant', price: 2.99};
</code></pre>
<p>It is possible to insert the results of a query:</p>
<pre><code class="language-sql">INSERT INTO cheap_products SELECT * FROM products WHERE price &lt; 4.00;
</code></pre>
<h2 id="update"><a class="header" href="#update">UPDATE</a></h2>
<p>To update an existing row, you can use the standard SQL <code>UPDATE</code> command:</p>
<pre><code class="language-sql">UPDATE products SET price = 4.99 WHERE name = 'Coffee';
</code></pre>
<p>Set multiple columns by separating them with commads;</p>
<pre><code class="language-sql">UPDATE products SET price = 4.99, name = 'Kaapi' WHERE name = 'Coffee';
</code></pre>
<p>Because Endb is schemaless, each document (or row) has its own schema.
As a result, you may want to remove a column from an individual row.
You can do this with the <code>UNSET</code> operator:</p>
<pre><code class="language-sql">UPDATE products UNSET product_no WHERE name = 'Coffee';
UPDATE products REMOVE product_no WHERE name = 'Coffee';
</code></pre>
<p><code>REMOVE</code> is an alias for <code>UNSET</code>.</p>
<p>It is possible to set and unset values in a single update.
Unsetting a column which doesn't exist is not an error:</p>
<pre><code class="language-sql">UPDATE products SET price = 5.98 UNSET product_no WHERE name = 'Coffee';
</code></pre>
<h2 id="update-patch"><a class="header" href="#update-patch">UPDATE PATCH</a></h2>
<p>Endb provides a <code>PATCH</code> operator, similar to the <a href="sql/functions.html#patch"><code>PATCH</code> function</a>.
The <code>PATCH</code> operator is used in conjunction with <code>UPDATE</code>
to set fields on a document (columns on a row) in a declarative fashion.</p>
<pre><code class="language-sql">UPDATE products PATCH {price: 1.98, product_no: products.product_no + 1000} WHERE price = 2.00;
</code></pre>
<p><code>PATCH</code> is based on <a href="https://datatracker.ietf.org/doc/html/rfc7386">RFC 7386: JSON Merge Patch</a>.</p>
<h2 id="update-set-path"><a class="header" href="#update-set-path">UPDATE SET $path</a></h2>
<p>The <code>SET</code> operator permits <a href="sql/path_navigation.html#path-functions">paths</a>
on its left-hand side.
The behaviour of the form <code>UPDATE &lt;table&gt; SET &lt;path&gt; = &lt;value&gt;</code>
is identical to that of the <a href="sql/path_navigation.html#path_set"><code>path_set</code></a>
function.</p>
<pre><code class="language-sql">UPDATE users SET $.addresses[0].city = 'Chicago' WHERE name = 'Steven';
</code></pre>
<h2 id="update-unset-path"><a class="header" href="#update-unset-path">UPDATE UNSET $path</a></h2>
<p>The <code>UNSET</code> (synonym: <code>REMOVE</code>) operator permits
<a href="sql/path_navigation.html#path-functions">paths</a> on its left-hand side.
The behaviour of the form <code>UPDATE &lt;table&gt; UNSET &lt;path&gt; = &lt;value&gt;</code>
is identical to that of the <a href="sql/path_navigation.html#path_remove"><code>path_remove</code></a>
function.</p>
<pre><code class="language-sql">UPDATE users UNSET $.addresses[0].city WHERE name = 'Steven';
</code></pre>
<h2 id="delete"><a class="header" href="#delete">DELETE</a></h2>
<p>To delete an existing row, use the standard SQL <code>DELETE</code> command.</p>
<pre><code class="language-SQL">DELETE FROM products WHERE price = 5.98;
</code></pre>
<p>You may delete all rows from a table by eliding the <code>WHERE</code> clause:</p>
<pre><code class="language-SQL">DELETE FROM products;
</code></pre>
<p>Note: In Endb, <code>DELETE</code> does not remove any data.
It is always possible to view data prior to the <code>DELETE</code> with
<a href="sql/time_queries.html">time queries</a>.
If you need to remove data for compliance (with laws such as GDPR or PIPEDA),
use <a href="sql/data_manipulation.html#erase"><code>ERASE</code></a>.</p>
<h2 id="on-conflict-upsert"><a class="header" href="#on-conflict-upsert">ON CONFLICT (Upsert)</a></h2>
<p>Endb provides flexible upserts with the common <code>ON CONFLICT</code> clause.
When the <code>INSERT</code> command detects a conflict, it will perform the instructions in the <code>DO</code> clause.
The following command needs to be executed twice to see the upsert effect.</p>
<pre><code class="language-sql">INSERT INTO products {name: 'Pepper', price: 9.99} ON CONFLICT (name, price) DO UPDATE SET v = 2;
</code></pre>
<p>To specify no operation on conflict, use <code>DO NOTHING</code>:</p>
<pre><code class="language-sql">INSERT INTO products {name: 'Pepper', price: 9.99} ON CONFLICT (name, price) DO NOTHING;
</code></pre>
<p>To reference the document currently being inserted, the <code>DO</code> clause provides
a statement-local relation named <code>excluded</code>.</p>
<pre><code class="language-sql">INSERT INTO products {name: 'Salt', price: 6};
INSERT INTO products {name: 'Salt', price: 7} ON CONFLICT (name) DO UPDATE SET price = excluded.price;
</code></pre>
<p>Similarly, the existing table is still available in the <code>DO</code> clause to provide further filtering:</p>
<pre><code class="language-sql">INSERT INTO products {product_no: 99, name: 'Cumin', price: 3.00, v: 5};
INSERT INTO products {product_no: 99, name: 'Cumin', price: 5.00, v: 6} ON CONFLICT (product_no, name) DO UPDATE SET price = excluded.price, v = excluded.v WHERE products.v &lt; 6;
</code></pre>
<h2 id="erase"><a class="header" href="#erase">ERASE</a></h2>
<p><code>ERASE</code> completely removes documents (rows) from visibility to any queries.
Once a document has been erased, it is no longer possible to query for it at all.</p>
<pre><code class="language-sql">ERASE FROM products WHERE name = 'Salt';
</code></pre>
<h2 id="with-common-table-expressions"><a class="header" href="#with-common-table-expressions">WITH (Common Table Expressions)</a></h2>
<p>The <code>WITH</code> keyword can create <em>Common Table Expressions</em> (CTEs) for DML, just as it can
<a href="sql/queries.html#with-common-table-expressions">for queries</a>.</p>
<pre><code class="language-sql">WITH top_margin_products AS (SELECT product_no, name FROM products WHERE (price - cost) &gt; 5.00)
INSERT INTO banner_products SELECT product_no, name FROM top_margin_products;
</code></pre>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<p>Parameters to DML are documented under the <a href="sql/../reference/http_api.html">HTTP API</a>.</p>
<h2 id="transactions"><a class="header" href="#transactions">Transactions</a></h2>
<p>Transactions in Endb are implicit.
Run multiple DML statements in a single transaction by providing multiple statements
(delimited by semicolons) to a single <code>POST</code> to the <a href="sql/../reference/http_api.html">HTTP API</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Endb SQL strives to empower the query author.
Basic SQL queries should be familiar.
Advanced SQL queries should be simple.</p>
<h2 id="select-"><a class="header" href="#select-">SELECT *</a></h2>
<p>The most common hand-written SQL query tends to be the easiest:</p>
<pre><code class="language-sql">SELECT * FROM products;
</code></pre>
<p>Without a <code>WHERE</code> clause (discussed below) the entire table is returned.
Because Endb is schemaless, <code>*</code> has a special meaning.
Each document (row) in Endb carries with it its own schema.
As a result, <code>*</code> refers to the widest possible set of columns, across all the rows returned.</p>
<p>In many SQL dialects, columns are strictly ordered.
Because Endb columns cannot have a strict order, <code>*</code> returns them in alphabetical order.</p>
<p>You can select the widest set of columns for a specific table with <code>&lt;table&gt;.*</code>:</p>
<pre><code class="language-sql">SELECT p.* FROM products p JOIN coupons c ON p.price = c.price;
</code></pre>
<h2 id="select"><a class="header" href="#select">SELECT</a></h2>
<p>In programmatic environments, it is almost always preferable to query for specific columns by name:</p>
<pre><code class="language-sql">SELECT product_no, price FROM products;
</code></pre>
<p>Select a list of columns by delimiting them with commas.</p>
<pre><code class="language-sql">SELECT product_no, v, price, name FROM products;
</code></pre>
<p>Select a column with spaces by delimiting it with backticks or square braces:</p>
<pre><code class="language-sql">SELECT products['product no'] FROM products;
SELECT `product no` FROM products;
</code></pre>
<p>NOTE: Whether or not your Endb client respects column ordering is dependent
on the content type it uses in Accept Headers.
It is worth reading over the <a href="sql/../reference/http_api.html#accept-header">Accept Header</a>
documentation, in this regard.</p>
<p>Limit query results to distinct rows or expand to all rows with <code>DISTINCT</code> and <code>ALL</code>.</p>
<pre><code class="language-sql">SELECT DISTINCT name FROM products;
SELECT ALL product_no FROM products p JOIN sales s ON p.name = s.name;
</code></pre>
<h2 id="from"><a class="header" href="#from">FROM</a></h2>
<h3 id="alias-tables"><a class="header" href="#alias-tables">Alias Tables</a></h3>
<p>For convenience, tables can be given aliases immediately following their name in the <code>FROM</code> clause.</p>
<pre><code class="language-sql">SELECT p.name FROM products p;
</code></pre>
<p>The <code>AS</code> operator can also (optionally) be used to provide an alias for a table.</p>
<pre><code class="language-sql">SELECT p.name FROM products AS p;
</code></pre>
<p>More usefully, it can give a temporary table name to an expression.
The temporary table name can either have anonymous columns or named columns.
(The <a href="sql/queries.html#values-lists"><code>VALUES</code> keyword</a> is explained in the following
<em>VALUES Lists</em> section.)</p>
<pre><code class="language-sql">SELECT p.column1 FROM (VALUES ('Paprika', 4.77)) AS p;
SELECT p.price FROM (VALUES ('Paprika', 4.77)) AS p(name, price);
</code></pre>
<h3 id="alias-columns"><a class="header" href="#alias-columns">Alias Columns</a></h3>
<p>The <code>AS</code> keyword is also used to alias columns.
This is useful when column names conflict in a join.
(Joins are explained below.)
If the same column is specified more than once, the last reference to that column name
is the one which will be returned:</p>
<pre><code class="language-sql">SELECT c.price, p.price FROM products p JOIN coupons c ON p.name = c.name;
</code></pre>
<p>If both columns are required, <code>AS</code> can be used to rename one or both of the columns:</p>
<pre><code class="language-sql">SELECT p.price AS regular_price, c.price FROM products p JOIN coupons c ON p.name = c.name;
</code></pre>
<h3 id="join"><a class="header" href="#join">JOIN</a></h3>
<p>Because Endb is schemaless, documents (rows) can be joined
on any fields (columns) which have equivalent values.
Joins are written in the form
<code>&lt;table1&gt; JOIN &lt;table2&gt; ON &lt;table1&gt;.&lt;column1&gt; &lt;operator&gt; &lt;table2&gt;.&lt;column2&gt;</code>.
Join operators are generally
<a href="sql/operators.html#comparison">comparisons</a> or
<a href="sql/operators.html#boolean-operators">booleans</a>.</p>
<pre><code class="language-sql">INSERT INTO coupons {name: 'Salt', price: 3.0};
SELECT * FROM products p JOIN coupons c ON p.name = c.name;
</code></pre>
<p><code>LEFT JOIN</code>, <code>LEFT OUTER JOIN</code>, <code>INNER JOIN</code>, and <code>CROSS JOIN</code> are all supported.</p>
<p>NOTE: Endb does not restrict name clashes in unqualified column selection or <code>SELECT *</code>.
If two tables share the same column name, the results from the column of the second table
in the join will be visible in the returned result, but not the results of the first.</p>
<h3 id="using"><a class="header" href="#using">USING</a></h3>
<p>When the columns to join share the same name between two tables, <code>USING</code> is a shorthand
that permits joining on the equality of those two columns.
A <code>USING</code> query also supports unambiguous use of the unqualified column name in the <code>SELECT</code>
clause.</p>
<pre><code class="language-sql">SELECT project_name, users.name, projects.budget FROM users JOIN projects USING (project_name);
</code></pre>
<h2 id="where-filtering"><a class="header" href="#where-filtering">WHERE (Filtering)</a></h2>
<p>Rather than returning the entire table, documents (rows) can be filtered with a <code>WHERE</code> clause.</p>
<pre><code class="language-sql">SELECT * FROM products WHERE price &gt; 4;
</code></pre>
<h3 id="advanced-filtering"><a class="header" href="#advanced-filtering">Advanced Filtering</a></h3>
<p>More advanced filters are documented in <a href="sql/operators.html">Operators</a>
and <a href="sql/functions.html">Functions</a>.</p>
<h2 id="order-by-sorting-results"><a class="header" href="#order-by-sorting-results">ORDER BY (Sorting Results)</a></h2>
<p>Results from queries can be ordered with standard SQL <code>ORDER BY</code>.</p>
<pre><code class="language-sql">SELECT * FROM products ORDER BY price;
</code></pre>
<p>By default, ordering is ascending.
For descending order, suffix the <code>ORDER BY</code> clause with <code>DESC</code>:</p>
<pre><code class="language-sql">SELECT * FROM products ORDER BY price DESC;
</code></pre>
<p>To force ascending order, use <code>ASC</code>:</p>
<pre><code class="language-sql">SELECT * FROM products ORDER BY price ASC;
</code></pre>
<p>It is also possible to order by an expression:</p>
<pre><code class="language-sql">SELECT * FROM products ORDER BY LENGTH(name);
SELECT * FROM products ORDER BY -price;
</code></pre>
<p>In the example above, <code>LENGTH</code> is an example of a function.
A complete list of functions can be found in the <a href="sql/functions.html">Functions</a> documentation.</p>
<h2 id="group-by"><a class="header" href="#group-by">GROUP BY</a></h2>
<p><code>GROUP BY</code> accepts a list of columns and creates aggregated rows based on
each of those columns, in order.
Each aggregate is returned as a single row.
Each column returned must either be a column specified in the <code>GROUP BY</code>
clause or a column created with an <a href="sql/functions.html#aggregate-functions">aggregate function</a>,
such as <code>SUM</code>.</p>
<pre><code class="language-sql">SELECT name, price FROM products GROUP BY name, price;
SELECT name, SUM(price) FROM products GROUP BY name;
</code></pre>
<h2 id="having"><a class="header" href="#having">HAVING</a></h2>
<p><code>HAVING</code> adds a search condition to an aggregate query.</p>
<pre><code class="language-sql">SELECT name, SUM(price) FROM products GROUP BY name HAVING LENGTH(name) &gt; 4;
</code></pre>
<p>It is most often used with <code>GROUP BY</code> (seen above), but it is also legal
with other aggregates:</p>
<pre><code class="language-sql">SELECT SUM(products.price) FROM products HAVING SUM(products.price) = 13;
</code></pre>
<h2 id="limit"><a class="header" href="#limit">LIMIT</a></h2>
<p><code>LIMIT</code> specifies the maximum number of rows to be returned by the query.</p>
<pre><code class="language-sql">SELECT * FROM products LIMIT 2;
</code></pre>
<p>It always makes sense to control the order of returned rows so <code>LIMIT</code>
always returns the same rows for the same query
-- unless you don't care which rows are returned.</p>
<pre><code class="language-sql">SELECT * FROM products ORDER BY price ASC LIMIT 2;
</code></pre>
<p><code>OFFSET</code> allows queries to skip rows before returning a limited set.</p>
<pre><code class="language-sql">SELECT * FROM products ORDER BY price ASC LIMIT 2 OFFSET 2;
</code></pre>
<h2 id="values-lists"><a class="header" href="#values-lists">VALUES Lists</a></h2>
<p>The <code>VALUES</code> keyword is used to create a static table of documents (rows).
Each row is denoted by a pair of parentheses.
All rows must have <a href="sql/queries.html#union-compatibility">Union Compatibility</a>
which, for Endb, means they have the same number of columns.</p>
<pre><code class="language-sql">VALUES (1, 'Salt'), (2, 'Pepper'), (3, 'Vinegar');
</code></pre>
<p>Endb assigns anonymous columns the names <code>column1</code>, <code>column2</code>, etc.
Columns can instead be given names with a
<a href="sql/queries.html#as-alias-tables-expressions-and-columns">table alias</a>:</p>
<pre><code class="language-sql">SELECT * FROM (VALUES (1, 'Salt'), (2, 'Pepper'), (3, 'Vinegar')) AS t (product_no, name);
</code></pre>
<h2 id="objects-lists"><a class="header" href="#objects-lists">OBJECTS Lists</a></h2>
<p>The <code>OBJECTS</code> keyword is used to create a static table comprised of
object literals, each representing a document (row).
Each row is directly denoted by an object literal.
<code>OBJECTS</code> lists do <em>not</em> require <a href="sql/queries.html#union-compatibility">Union Compatibility</a>,
so jagged lists are permitted.</p>
<pre><code class="language-sql">OBJECTS {product_no: 1, name: 'Salt'}, {product_no: 2, name: 'Pepper', price: 3.99};
SELECT * FROM (OBJECTS {product_no: 1, name: 'Salt'}, {product_no: 2, name: 'Pepper'}) as t;
</code></pre>
<h2 id="set-operations-union-intersect-except"><a class="header" href="#set-operations-union-intersect-except">Set Operations: UNION, INTERSECT, EXCEPT</a></h2>
<p>The set operations union, intersection, and difference
are available to the results of two queries.</p>
<h3 id="union"><a class="header" href="#union">UNION</a></h3>
<p>Append the results of one query to another.
Duplicate rows are removed.</p>
<pre><code class="language-sql">SELECT * FROM products UNION SELECT * FROM new_products;
</code></pre>
<p>To keep duplicate rows, use <code>UNION ALL</code>:</p>
<pre><code class="language-sql">SELECT * FROM products UNION ALL SELECT * FROM new_products;
</code></pre>
<h3 id="intersect"><a class="header" href="#intersect">INTERSECT</a></h3>
<p>The intersection of two queries returns results which are found in both.</p>
<pre><code class="language-sql">SELECT * FROM products INTERSECT SELECT * FROM new_products;
</code></pre>
<h3 id="except"><a class="header" href="#except">EXCEPT</a></h3>
<p>The difference of two queries returns only results from the first query which are not found in the second.
Another way of thinking about this is that results of the second query are removed from the first.</p>
<pre><code class="language-sql">SELECT * FROM products EXCEPT SELECT * FROM ignored_products;
</code></pre>
<h3 id="union-compatibility"><a class="header" href="#union-compatibility">Union-Compatibility</a></h3>
<p>&quot;Union Compatibility&quot; refers to the ability of two queries to be used in a union, intersection, or difference.
Because Endb is dynamically-typed, the only constraint on union compatibility is the number of columns returned.</p>
<p>In general, it only makes sense to use set operations on two queries which return either: (1) explicit columns, so
order and naming are respected or (2) columns with the same names, so they are guaranteed to return in order, in
the case of <code>*</code> queries.
When applying set operations to <code>*</code> queries, keep in mind that the widest column set (across the entire history of
the table) will be returned.</p>
<p>If the queries return a different number of columns, set operations will result in an error:</p>
<pre><code class="language-sql">-&gt; SELECT * FROM products UNION SELECT * FROM new_products;
400 Bad Request
Number of UNION left columns: 3 does not match right columns: 2
</code></pre>
<h2 id="with-common-table-expressions-1"><a class="header" href="#with-common-table-expressions-1">WITH (Common Table Expressions)</a></h2>
<p>The <code>WITH</code> keyword is used to create <em>Common Table Expressions</em>, or CTEs.
CTEs act like temporary tables or views within the context of a query or
<a href="sql/data_manipulation.html#with-common-table-expressions">DML statement</a>.
CTEs are used in place of a sub-select to simplify the appearance of a query.
<code>WITH</code> clauses take the form <code>WITH &lt;cte-name&gt; AS (&lt;cte-select&gt;)</code>.</p>
<pre><code class="language-sql">WITH top_margin_products AS (SELECT product_no FROM products WHERE (price - cost) &gt; 5.00)
SELECT name FROM products
WHERE product_no IN (SELECT product_no FROM top_margin_products);
</code></pre>
<h2 id="with-recursive"><a class="header" href="#with-recursive">WITH RECURSIVE</a></h2>
<p>The <code>RECURSIVE</code> keyword can be added to <code>WITH</code> to create recursive CTEs
which can refer to themselves.
Recursive CTEs will always have the form <code>&lt;initial-select&gt; UNION &lt;recursive-select&gt;</code>
or <code>&lt;initial-select&gt; UNION ALL &lt;recursive-select&gt;</code>.</p>
<p>Here is a naive example, demonstrating the recursive construction of a Fibonacci Sequence:</p>
<pre><code class="language-sql">WITH RECURSIVE fib(previous, current) AS (
  VALUES (0, 1)
    UNION ALL
  SELECT fib.current, fib.previous + fib.current
  FROM fib
  WHERE fib.previous + fib.current &lt; 5000
)
SELECT * FROM fib;
</code></pre>
<p>The most beneficial uses for <code>WITH RECURSIVE</code> are walking hierarchical and graph-shaped data sets
-- capabilities ordinary SQL lacks.
However, Endb recursive queries are also capable of solving Sudoku puzzles and constructing fractals,
<a href="https://github.com/endatabas/endb/blob/main/test/sql.lisp">as seen in the test suite</a>.
(Credit goes to SQLite's delightful
<a href="https://www.sqlite.org/lang_with.html#outlandish_recursive_query_examples">Outlandish Recursive Query Examples</a>.)</p>
<h2 id="lateral"><a class="header" href="#lateral">LATERAL</a></h2>
<p>Lateral queries permit access to named values from the <code>FROM</code> clause in the <code>SELECT</code> clause.
The <code>LATERAL</code> keyword is optional in Endb as all queries are lateral queries by default.</p>
<pre><code class="language-sql">SELECT halved FROM products, LATERAL (SELECT price / 2.0 AS halved) h;
SELECT halved FROM products, (SELECT price / 2.0 AS halved) h;
</code></pre>
<h2 id="repeatable-reads-savepoint-rollback-release"><a class="header" href="#repeatable-reads-savepoint-rollback-release">Repeatable Reads: SAVEPOINT, ROLLBACK, RELEASE</a></h2>
<p>Repeatable reads are achieved in Endb by creating <em>savepoints</em>, which queries can return to later.
When returning to a savepoint in the future, queries will return results according to the state
of the database when the savepoint was captured.</p>
<p>By default, savepoints have a 60-second lifespan, after which they expire.
Use of a savepoint during its lifespan will renew its lease, allowing it to be used for another
60 seconds.
Savepoints can be forcibly expired with <code>RELEASE</code>.
Attempting to use a savepoint that has been expired or released will return
<code>No active savepoint: &lt;savepoint&gt;</code>.</p>
<h3 id="minimal-example"><a class="header" href="#minimal-example">Minimal Example</a></h3>
<p>Other SQL dialects have more transaction-specific semantics for <code>SAVEPOINT</code>, <code>ROLLBACK</code>, and
<code>RELEASE</code>.
Because this difference in behaviour may be confusing to users familiar with other databases,
we provide the example below.
The result of the final query returns the first two dungeons, which were inserted prior to
the savepoint, but not <code>&quot;Tower of Hera&quot;</code>.</p>
<pre><code class="language-sh">INSERT INTO dungeons {name: 'Eastern Palace'};
INSERT INTO dungeons {name: 'Desert Palace'};
SAVEPOINT desert_palace;
INSERT INTO dungeons {name: 'Tower of Hera'};
ROLLBACK TO desert_palace; SELECT * FROM dungeons;
</code></pre>
<p>NOTE: The <code>ROLLBACK</code> and <code>SELECT</code> above must be executed together, in the same transaction.
(Normally this will mean executing both statements in a single HTTP request.)</p>
<h3 id="savepoint"><a class="header" href="#savepoint">SAVEPOINT</a></h3>
<p>The <code>SAVEPOINT</code> operator captures a new savepoint at the time it executes.
Savepoints can be named or anonymous.
Anonymous savepoints are named with a UUID.
The name of the savepoint is returned as an attribute named <code>result</code>.</p>
<pre><code class="language-sql">SAVEPOINT desert_palace;
-- [{'result': 'desert_palace'}]
SAVEPOINT;
-- [{'result': '0b12de43-1c92-4d92-ab7c-51c5a5129074'}]
</code></pre>
<h3 id="rollback"><a class="header" href="#rollback">ROLLBACK</a></h3>
<p>Inside the scope of a transaction (normally a single HTTP request), <code>ROLLBACK</code> is used to
return to a savepoint.
<code>ROLLBACK TO &lt;savepoint&gt;</code> returns to a named savepoint (by name) or an anonymous savepoint
(by string UUID).
When used without a savepoint name, <code>ROLLBACK</code> returns to the last anonymous savepoint.
Queries executed inside such a transaction return results according to the state of the
database when the savepoint was created.
The use of <code>ROLLBACK</code> renews the lease of the associated savepoint.</p>
<pre><code class="language-sql">ROLLBACK TO desert_palace; SELECT * FROM dungeons;
ROLLBACK TO 'eab07765-de6f-4f74-8052-838dd29ee8e7'; SELECT * FROM dungeons;
ROLLBACK; SELECT * FROM dungeons;
</code></pre>
<h3 id="release"><a class="header" href="#release">RELEASE</a></h3>
<p>The <code>RELEASE</code> keyword expires a savepoint so it can no longer be used.
Anonymous savepoints can be released by string UUID.</p>
<pre><code class="language-sql">RELEASE desert_palace;
RELEASE 'f7c314dd-47b9-4c85-9502-b8e35c82b935';
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-data-types"><a class="header" href="#sql-data-types">SQL Data Types</a></h1>
<h2 id="null"><a class="header" href="#null">NULL</a></h2>
<p>Null serves a variety of purposes in Endb.</p>
<ul>
<li>Explicit: You can provide an explicit <code>NULL</code> value</li>
<li>&quot;Unknown&quot;: As with any SQL, you will receive a null when <a href="https://en.wikipedia.org/wiki/Three-valued_logic#SQL">3-Valued Logic</a>
cannot determine if a statement is true or false</li>
<li>&quot;Missing&quot;: Jagged rows will return <code>NULL</code> for columns projected
for a document which does not contain them</li>
</ul>
<h2 id="text-char-varchar"><a class="header" href="#text-char-varchar">TEXT (CHAR, VARCHAR)</a></h2>
<p>Endb accepts unbounded, variable-length strings with either single or double quotes.
<code>CHAR</code> and <code>VARCHAR</code> are synonyms for <code>TEXT</code>.</p>
<pre><code class="language-sql">INSERT INTO users (name, title) VALUES ('River', &quot;Prodigy&quot;);
</code></pre>
<p>When casting using the <code>CHAR</code> synonym, an optional integer argument indicates the
desired length of the resulting string, padded with spaces:</p>
<pre><code class="language-sql">SELECT CAST(123 AS CHAR(10));
-- [{'column1': '123       '}]
</code></pre>
<h2 id="boolean"><a class="header" href="#boolean">BOOLEAN</a></h2>
<p>Boolean values can be <code>TRUE</code>, <code>FALSE</code>, or <code>NULL</code>.</p>
<h2 id="integer-bigint"><a class="header" href="#integer-bigint">INTEGER (BIGINT)</a></h2>
<p>64-bit integer capable of auto-promotion to 128-bit integer.</p>
<h2 id="real-double"><a class="header" href="#real-double">REAL (DOUBLE)</a></h2>
<p>A 64-bit IEEE 754 floating point number, or double.</p>
<h2 id="timestamp"><a class="header" href="#timestamp">TIMESTAMP</a></h2>
<p>Timestamps can be represented as either SQL timestamps, according to the SQL Specification,
or ISO timestamps.
The following are legal timestamp literals:</p>
<ul>
<li><code>2007-01-01T00:00:00</code></li>
<li><code>2007-01-01T00:00:00.123Z</code></li>
<li><code>2007-01-01T00:00:00.000000Z</code></li>
<li><code>TIMESTAMP '2007-01-01 00:00:00'</code></li>
<li><code>TIMESTAMP '2007-01-01 00:00:00.000000Z'</code></li>
</ul>
<h2 id="date"><a class="header" href="#date">DATE</a></h2>
<p>Dates can be represented as either SQL dates, according to the SQL Specification,
or ISO dates.
The following are legal date literals:</p>
<ul>
<li><code>2007-01-01</code></li>
<li><code>DATE '2007-01-01'</code></li>
</ul>
<h2 id="time"><a class="header" href="#time">TIME</a></h2>
<p>Times can be represented as either SQL times, according to the SQL Specification,
or ISO times.
The following are legal time literals:</p>
<ul>
<li><code>23:59:12</code></li>
<li><code>23:59:12.12345</code></li>
<li><code>TIME '23:59:12'</code></li>
<li><code>TIME '23:59:12.12345'</code></li>
</ul>
<h2 id="interval-duration"><a class="header" href="#interval-duration">INTERVAL (DURATION)</a></h2>
<p>An interval (or <em>duration</em>) is created whenever two times are subtracted.</p>
<pre><code class="language-sql">SELECT 2001-01-02 - 2001-01-01;
</code></pre>
<p>Interval literals can be constructed with
<a href="https://en.wikipedia.org/wiki/ISO_8601#Time_intervals">ISO 8601 syntax</a>:</p>
<ul>
<li><code>PT12H30M5S</code></li>
<li><code>P1Y2M10DT2H30M</code></li>
</ul>
<p>This is equivalent to the same ISO 8601 syntax
provided as a string to the <code>DURATION</code> constructor:</p>
<ul>
<li><code>DURATION('PT12H30M5S')</code></li>
<li><code>DURATION('P1Y2M10DT2H30M')</code></li>
</ul>
<p>Interval literals can also be constructed with
the classic SQL intervals DSL:</p>
<ul>
<li><code>INTERVAL '1-2' YEAR TO MONTH</code></li>
<li><code>INTERVAL '0 12:34:56.789' DAY TO SECOND</code></li>
</ul>
<h2 id="blob-varbinary"><a class="header" href="#blob-varbinary">BLOB (VARBINARY)</a></h2>
<p>Binary Large Objects can be encoded as hexidecimal literals or cast from strings.</p>
<ul>
<li><code>x'DEADBEEF'</code></li>
<li><code>CAST(&quot;hello&quot; AS BLOB)</code></li>
</ul>
<h2 id="array"><a class="header" href="#array">ARRAY</a></h2>
<p>Arrays can be created with array literals similar to JSON.</p>
<ul>
<li><code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</code></li>
</ul>
<p>Alternatively, arrays can also be created using a literal syntax similar
to that in the SQL Specification or a constructor function.</p>
<ul>
<li><code>ARRAY [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</code></li>
<li><code>ARRAY(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)</code></li>
</ul>
<p>Array literals can contain the <a href="sql/data_types.html#spread">spread operator</a></p>
<pre><code class="language-sql">SELECT [1, 2, ...[3, 4], 5];
-- [{'column1': [1, 2, 3, 4, 5]}]
</code></pre>
<p>Array equality is tested <a href="https://en.wikipedia.org/wiki/Lexicographic_order">lexicographically</a>.</p>
<h2 id="object"><a class="header" href="#object">OBJECT</a></h2>
<p>Objects (which can also be thought of as documents, or rows)
can be created with object literals enclosed in curly braces,
similar to JSON.
Keys in object literals can be quoted or unquoted.</p>
<ul>
<li><code>{name: &quot;Hanna&quot;, birthday: 1982-12-31}</code></li>
<li><code>{'name': &quot;Hanna&quot;, 'birthday': 1982-12-31}</code></li>
</ul>
<p>Alternatively, objects can be created using either an <code>OBJECT</code>
constructor keyword, similar to that in the SQL Specification.</p>
<ul>
<li><code>OBJECT(name: 'Hanna', birthday: 1982-12-31)</code></li>
</ul>
<p>Object literals can contain
<a href="sql/data_types.html#spreads">spreads</a>,
<a href="sql/data_types.html#computed-fields">computed fields</a>,
<a href="sql/data_types.html#shorthands">shorthands</a>, and
<a href="sql/data_types.html#row-literals">row literals</a>.</p>
<pre><code class="language-sql">SELECT { a: 1, ...[2, 3] };
-- [{'column1': {'0': 2, '1': 3, 'a': 1}}]
SELECT { foo: 2, ['foo' || 2]: 5 };
-- [{'column1': {'foo': 2, 'foo2': 5}}]
SELECT {p.name, c.discounted} FROM products p JOIN coupons c ON p.name = c.name;
-- [{'column1': {'discounted': 2.99, 'name': 'Salt'}}]
SELECT {product: {p.*}, discounted: c.discounted} FROM products p JOIN coupons c ON p.name = c.name;
-- [{'column1': {'discounted': 2.99, 'product': {'name': 'Salt', 'price': 5.99}}}]
</code></pre>
<p>Object equality is tested by comparing each key-value pair as an array.</p>
<h2 id="dynamic-literals"><a class="header" href="#dynamic-literals">Dynamic Literals</a></h2>
<h3 id="row-literals"><a class="header" href="#row-literals">Row Literals</a></h3>
<p>It is possible return an entire document (row) as a single literal value.
The syntax is akin to Postgres
<a href="https://www.postgresql.org/docs/current/rowtypes.html"><code>ROW</code> literals</a>.
Unlike <code>table.*</code>, which pads non-existent columns with <code>NULL</code>,
a row literal returns exactly the schema specified for each individual row.</p>
<ul>
<li><code>{ table.* }</code></li>
</ul>
<p>Example usage:</p>
<pre><code class="language-sql">SELECT { products.* } FROM products;
</code></pre>
<p>As a shorthand, a table's name may be used in the <code>SELECT</code> clause to return
entire rows as documents:</p>
<pre><code class="language-sql">-&gt; SELECT users FROM users;
-- [{'users': {'email': 'patrick@oracle.com', 'name': 'Patrick'}},
--  {'users': {'email': 'preethi@shopify.ca', 'name': 'Preethi'}}]
</code></pre>
<p>NOTE: When a table contains a column of the same name, the column takes precedence
and a single column is returned, as usual:</p>
<pre><code class="language-sql">-&gt; SELECT status FROM status;
-- [{'status': 'error'}, {'status': 'ok'}]
</code></pre>
<h3 id="spread"><a class="header" href="#spread">Spread</a></h3>
<p>The Spread Operator (<code>...</code>, sometimes known as &quot;splat&quot;)
can be used to directly flatten/unnest one collection
(an array, object, or row literal) into another.
Strings are treated as character collections.</p>
<pre><code class="language-sql">SELECT [1, 2, ...[3, 4], 5];
-- [{'column1': [1, 2, 3, 4, 5]}]

SELECT [1, 2, ...&quot;foo&quot;, 5];
-- [{'column1': [1, 2, 'f', 'o', 'o', 5]}]
</code></pre>
<p>If an array is spread into an object, its ordinals will be used as properties:</p>
<pre><code class="language-sql">SELECT { a: 1, ...{b: 2} };
-- [{'column1': {'a': 1, 'b': 2}}]

SELECT { a: 1, ...[2, 3] };
-- [{'column1': {'0': 2, '1': 3, 'a': 1}}]
</code></pre>
<h3 id="computed-fields"><a class="header" href="#computed-fields">Computed Fields</a></h3>
<p>In the key/property position, square brackets are used to construct
computed fields in <a href="sql/data_types.html#object">object literals</a>.
Computed fields are implicitly cast to string.</p>
<pre><code class="language-sql">SELECT { foo: 2, [2 + 2]: 5 };
-- [{'column1': {'4': 5, 'foo': 2}}]
SELECT { foo: 2, ['foo' || 2]: 5 };
-- [{'column1': {'foo': 2, 'foo2': 5}}]
</code></pre>
<h3 id="shorthands"><a class="header" href="#shorthands">Shorthands</a></h3>
<p>Column names can be referred to in place of key-value pairs in
<a href="sql/data_types.html#object">object literals</a>.</p>
<pre><code class="language-sql">SELECT {p.name, c.discounted} FROM products p JOIN coupons c ON p.name = c.name;
-- [{'column1': {'discounted': 2.99, 'name': 'Salt'}}]
</code></pre>
<h2 id="note-on-timezones"><a class="header" href="#note-on-timezones">Note on timezones</a></h2>
<p>Endb date/time data types currently only support times encoded as UTC.</p>
<h2 id="note-on-type-widening"><a class="header" href="#note-on-type-widening">Note on type widening</a></h2>
<p>Operations performed on scalars will attempt to widen those scalars for the purpose of the operation, if reasonable.</p>
<pre><code class="language-sql">-&gt; select 2.0 = 2;
[{'column1': True}]
</code></pre>
<p>This widening includes joins on scalars, but not collections (<code>ARRAY</code> or <code>OBJECT</code>):</p>
<pre><code class="language-sql">-&gt; INSERT INTO zig {at: 2023-12-21, val: 2}
[{'result': 1}]
-&gt; INSERT INTO zag {at: 2023-12-21T00:00:00, val: 2.0}
[{'result': 1}]
-&gt; SELECT * FROM zig i JOIN zag a ON i.at = a.at;
[{'at': datetime.datetime(2023, 12, 21, 0, 0, tzinfo=datetime.timezone.utc),
  'val': 2.0}]
-&gt; SELECT * FROM zig i JOIN zag a ON i.val = a.val;
[{'at': datetime.datetime(2023, 12, 21, 0, 0, tzinfo=datetime.timezone.utc),
  'val': 2.0}]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<p>Two values can be compared using standard SQL comparison operators:</p>
<ul>
<li><code>=</code>, <code>==</code> (equals)</li>
<li><code>&gt;</code> (greater than)</li>
<li><code>&lt;</code> (less than)</li>
<li><code>&gt;=</code> (greater than or equal to)</li>
<li><code>&lt;=</code> (less than or equal to)</li>
<li><code>&lt;&gt;</code>, <code>!=</code> (not equal to)</li>
</ul>
<pre><code class="language-sql">SELECT * FROM products WHERE NOT name = 'Coffee';
SELECT * FROM products WHERE name = 'Coffee' AND name &lt;&gt; 'Kaapi';
SELECT * FROM products WHERE name &gt; 'Cake' AND price &gt;= 5.00;
</code></pre>
<h2 id="between"><a class="header" href="#between">BETWEEN</a></h2>
<p><code>BETWEEN</code> returns <code>TRUE</code> when a value is greater-than-or-equal-to the first limit
and less-than-or-equal-to the second.
It has the form <code>BETWEEN x AND y</code>.
It can be negated with the form <code>NOT BETWEEN x AND y</code>.</p>
<pre><code class="language-sql">SELECT * FROM products WHERE price BETWEEN 2.00 AND 4.00;
SELECT * FROM products WHERE price NOT BETWEEN 2.00 AND 4.00;
</code></pre>
<p>NOTE: <code>BETWEEN</code> can also be used with <a href="sql/time_queries.html#between">System Time</a>.</p>
<h2 id="boolean-operators"><a class="header" href="#boolean-operators">Boolean Operators</a></h2>
<p><code>WHERE</code> and <code>HAVING</code> clauses can be modified and combined with standard SQL boolean operators.</p>
<h3 id="is-is-not"><a class="header" href="#is-is-not">IS, IS NOT</a></h3>
<p><code>IS</code> and <code>IS NOT</code> behave like <a href="sql/operators.html#comparison"><code>=</code> (<code>==</code>) and <code>&lt;&gt;</code> (<code>!=</code>)</a>, respectively.
They are usually used to augment equality checks to test for <code>NULL</code>,
which is the third boolean value, representing &quot;unknown&quot;.
The literal <code>UNKNOWN</code> is permitted in <code>IS</code> / <code>IS NOT</code> expressions in place of <code>NULL</code>.</p>
<ul>
<li>When both sides of <code>IS</code> evaluate to <code>NULL</code> it returns <code>TRUE</code>.</li>
<li>When only one side of <code>IS NOT</code> evaluates to <code>NULL</code> it returns <code>TRUE</code>,</li>
<li>When only one side of <code>IS</code> evaluates to <code>NUll</code> it returns <code>FALSE</code>.</li>
<li>When both sides of <code>IS NOT</code> evaluates to <code>NULL</code> it returns <code>FALSE</code>.</li>
</ul>
<pre><code class="language-sql">SELECT * FROM products WHERE product_no IS NULL;
SELECT * FROM products WHERE product_no IS UNKNOWN;
SELECT * FROM products WHERE product_no IS NOT NULL;
SELECT * FROM products WHERE product_no IS 386;
SELECT * FROM products WHERE product_no IS NOT 444;
</code></pre>
<p>NOTE: A <code>WHERE</code> clause of the form <code>&lt;column&gt; IS NULL</code> will <em>not</em> return
rows for which <code>&lt;column&gt;</code> does not exist, as positive equality is only
tested against extant columns.
For example, the query <code>SELECT * FROM products WHERE name IS NULL;</code> will
not return rows for which the column <code>name</code> does not exist.
However, <code>SELECT * FROM products WHERE name IS NOT NULL;</code> will not return
either rows where the <code>name</code> column has a value of <code>NULL</code> or the <code>name</code>
column is missing.
Thus, <code>IS</code> and <code>IS NOT</code> are not symmetrical for jagged data.</p>
<h3 id="is-not-distinct-from"><a class="header" href="#is-not-distinct-from">IS [NOT] DISTINCT FROM</a></h3>
<p><code>IS DISTINCT FROM</code> is a synonym for <code>IS NOT</code>.
<code>IS NOT DISTINCT FROM</code> is a synonym for <code>IS</code>.</p>
<p>NOTE: The <code>IS \[NOT\] DISTINCT FROM</code> form is provided for SQL specification
compatibility and is not recommended, as it tends to be verbose and confusing.</p>
<h3 id="not-and-or"><a class="header" href="#not-and-or">NOT, AND, OR</a></h3>
<p><code>NOT</code> can be prefixed to any clause to negate it:</p>
<pre><code class="language-sql">SELECT * FROM products WHERE NOT (name = 'Coffee');
</code></pre>
<p><code>AND</code> returns true if two clauses both return true:</p>
<pre><code class="language-sql">SELECT * FROM products WHERE name = 'Coffee' AND price &gt; 2.99;
</code></pre>
<p><code>OR</code> returns true if either of two clauses return true:</p>
<pre><code class="language-sql">SELECT * FROM products WHERE name = 'Coffee' OR name = 'Kaapi';
</code></pre>
<h2 id="math"><a class="header" href="#math">Math</a></h2>
<p>Standard SQL mathemetical operators are available to any two numeric values:</p>
<ul>
<li><code>+</code> (addition)</li>
<li><code>-</code> (subtraction)</li>
<li><code>*</code> (multiplication)</li>
<li><code>/</code> (division)</li>
<li><code>%</code> (modulo; integer remainder of division)</li>
<li><code>&lt;&lt;</code> (left bit shift)</li>
<li><code>&gt;&gt;</code> (right bit shift)</li>
<li><code>+NUMBER</code> (unary plus)</li>
<li><code>-NUMBER</code> (unary minus)</li>
</ul>
<pre><code class="language-sql">SELECT 1 + 3.555;
SELECT 1 - 3.555;
SELECT 2 * 3.555;
SELECT 2 / 3.555;
SELECT 2 % 3.555;
SELECT 62 &lt;&lt; 2;
SELECT 62 &gt;&gt; 2;
SELECT +128.5;
SELECT -128.5;
</code></pre>
<p>NOTE: Mathematical functions are documented under <a href="sql/functions.html#math">Functions</a>.</p>
<h2 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h2>
<p>Standard SQL bitwise manipulation operators are available to any two values.</p>
<ul>
<li><code>&amp;</code> (bitwise and)</li>
<li><code>|</code> (bitwise or)</li>
</ul>
<p>The bitwise <em>not</em> operator is also available to a single value:</p>
<ul>
<li><code>~</code> (bitwise not)</li>
</ul>
<pre><code class="language-sql">SELECT 1 &amp; 2;
SELECT 1 | 2;
SELECT ~1;
</code></pre>
<h2 id="like"><a class="header" href="#like">LIKE</a></h2>
<p><code>LIKE</code> is the operator equivalent of the <a href="sql/functions.html#like"><code>LIKE</code> function</a>.</p>
<p><code>LIKE</code> returns <code>TRUE</code> if a string matches the supplied <em>LIKE</em> pattern, as defined below:</p>
<p>A pattern can be a string literal.
It can also contain underscores (<code>_</code>) and/or percentage symbols (<code>%</code>).
An underscore matches exactly one character.
A percentage symbol matches zero or more characters.</p>
<p>Backslash escapes the following character to make it a literal.
Use <code>ESCAPE</code> to override the default backslash escape character.</p>
<pre><code class="language-sql">SELECT * FROM products WHERE name LIKE 'Tofu';
SELECT * FROM products WHERE name LIKE 'Tof_';
SELECT * FROM products WHERE name LIKE '%of%';
SELECT * FROM products WHERE name LIKE '\%of\%';
SELECT * FROM products WHERE name LIKE 'X%ofX%' ESCAPE 'X';
</code></pre>
<p><code>NOT LIKE</code> is used to invert the results of the match.</p>
<pre><code class="language-sql">SELECT * FROM products WHERE name NOT LIKE '%of%';
</code></pre>
<p>NOTE: Endb <code>LIKE</code> is case-sensitive.</p>
<h2 id="regexp"><a class="header" href="#regexp">REGEXP</a></h2>
<p><code>REGEXP</code> returns <code>TRUE</code> if a string matches the supplied regular expression.
<code>REGEXP</code> may be prefixed with <code>NOT</code>.</p>
<pre><code class="language-sql">SELECT * FROM products WHERE name REGEXP '.*ee|.*ea';
SELECT * FROM products WHERE name NOT REGEXP '.*[fst]+.*';
</code></pre>
<h2 id="glob"><a class="header" href="#glob">GLOB</a></h2>
<p><code>GLOB</code> returns <code>TRUE</code> if a string matches the supplied UNIX glob.
<code>GLOB</code> may be prefixed with <code>NOT</code>.</p>
<pre><code class="language-sql">SELECT * FROM products WHERE name GLOB '*of*';
SELECT * FROM avatars WHERE filename NOT GLOB '/opt/local/avatars/*/*.png';
</code></pre>
<p>NOTE: <code>GLOB</code> is case-sensitive.
It conforms to standard UNIX globs and thus does not support &quot;globstar&quot;
(recursive directory) expansion like <code>**/*.png</code>.</p>
<h2 id="match-containment"><a class="header" href="#match-containment">MATCH (Containment)</a></h2>
<p><code>MATCH</code> returns <code>TRUE</code> if the value on the left contains the value on the right,
at the top level.
Note that a top-level array to the right of the <code>MATCH</code> refers to a set of values
that all need to match, not a literal array.</p>
<p>The following expressions return <code>TRUE</code>:</p>
<pre><code class="language-sql">SELECT 'foo' MATCH 'foo';
SELECT [1, 2, 3] MATCH [3, 1];
SELECT {user: 'foo', age: 42} MATCH {age: 42};
SELECT {a: [1, 2, {c: 3, x: 4}], c: 'b'} MATCH {a: [{x: 4}, 1]};
</code></pre>
<p>The following expressions return <code>FALSE</code>:</p>
<pre><code class="language-sql">SELECT [1, 2, [1, 3]] MATCH [1, 3];
SELECT {foo: {bar: 'baz'}} MATCH {bar: 'baz'};
SELECT {a: [1, 2, {c: 3, x: 4}], c: 'b'} MATCH {a: [{x: 4}, 3]};
</code></pre>
<p>NOTE: The <code>@&gt;</code> operator is a synonym for <code>MATCH</code>.
It is provided as a convenience for users accustomed to the equivalent
<a href="https://www.postgresql.org/docs/current/datatype-json.html#JSON-CONTAINMENT">JSON Containment Operator in Postgres</a>.</p>
<h2 id="any-some"><a class="header" href="#any-some">ANY, SOME</a></h2>
<p><code>SOME</code> is a synonym for <code>ANY</code>.
<code>ANY</code> qualifies a subquery by comparing a single column or literal value with the result of that subquery.
<code>ANY</code> is used in the form <code>&lt;expression&gt; &lt;operator&gt; ANY (&lt;subquery&gt;)</code>.
It returns true if the subquery returns a one or more values for which the operator is true.
The operator must return a boolean and the subquery must return a single column.</p>
<pre><code class="language-sql">SELECT 1500 &lt; SOME (SELECT price FROM products);
</code></pre>
<h2 id="all"><a class="header" href="#all">ALL</a></h2>
<p><code>ALL</code> qualifies a subquery by comparing a single column or literal value with the result of that subquery.
<code>ALL</code> is used in the form <code>&lt;expression&gt; &lt;operator&gt; ALL (&lt;subquery&gt;)</code>.
It returns true only if all values returned by the subquery are true for the operator provided.
The operator must return a boolean and the subquery must return a single column.</p>
<pre><code class="language-sql">SELECT &quot;ok&quot; = ALL (SELECT status_code FROM statuses);
</code></pre>
<h2 id="exists"><a class="header" href="#exists">EXISTS</a></h2>
<p><code>EXISTS</code> returns <code>TRUE</code> if the subquery which follows it returns at least one row.</p>
<pre><code class="language-sql">SELECT name FROM products WHERE EXISTS (SELECT 1 FROM coupons WHERE name = products.name);
</code></pre>
<h2 id="in"><a class="header" href="#in">IN</a></h2>
<p>The standard SQL <code>IN</code> clause can be used to test lists and subqueries for containment of a value.</p>
<pre><code class="language-sql">SELECT * FROM products WHERE price IN (5.00, 5.99);
SELECT * FROM products WHERE price IN (SELECT price FROM coupons);
</code></pre>
<p>NOTE: Use <a href="sql/operators.html#match"><code>MATCH</code></a> to test for containment of a value in an array.</p>
<h2 id="not-in"><a class="header" href="#not-in">NOT IN</a></h2>
<p>The standard SQL <code>NOT IN</code> clause can be used to test lists and subqueries for absence of a value.</p>
<pre><code class="language-sql">SELECT * FROM products WHERE price NOT IN (5.00, 5.99);
SELECT * FROM products WHERE price NOT IN (SELECT price FROM coupons);
</code></pre>
<p>NOTE: Use <a href="sql/operators.html#match"><code>MATCH</code></a> to test for absence of a value in an array.</p>
<h2 id="-concatenation"><a class="header" href="#-concatenation"><code>||</code> (Concatenation)</a></h2>
<p>The <code>||</code> operator concatenates two strings or arrays supplied as arguments.
When concatenating to an array element: other elements, arrays, and blobs are accepted as the second argument.
When concatenating to an array: arrays, blobs, and array elements are accepted as the second argument.
Elements other than strings are cast to strings when concatenated with each other.
Multiple operators can be chained together.</p>
<pre><code class="language-sql">SELECT &quot;Hello&quot; || &quot;World&quot;;
SELECT [1, 2, 3] || [4, 5, 6];
SELECT 1 || 2;
SELECT &quot;Hello&quot; || [&quot;World&quot;];
SELECT [&quot;Hello&quot;] || &quot;World&quot;;
SELECT &quot;Hello&quot; || &quot;World&quot; || &quot;And&quot; || &quot;Friends&quot;;
</code></pre>
<p>The Concatenation Operator is equivalent to the <a href="sql/functions.html#concat"><code>CONCAT</code> function</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<h2 id="string-functions"><a class="header" href="#string-functions">String Functions</a></h2>
<h3 id="character_length"><a class="header" href="#character_length">CHARACTER_LENGTH</a></h3>
<p>The <code>CHARACTER_LENGTH</code> function returns the number of unicode characters in a string.</p>
<pre><code class="language-sql">SELECT CHARACTER_LENGTH('josé');
-- 4

SELECT CHARACTER_LENGTH('❤️🥫');
-- 3
</code></pre>
<h3 id="octet_length"><a class="header" href="#octet_length">OCTET_LENGTH</a></h3>
<p>The <code>OCTET_LENGTH</code> function returns the length of a string, in bytes (octets).</p>
<pre><code class="language-sql">SELECT OCTET_LENGTH('josé');
-- 5

SELECT OCTET_LENGTH('❤️🥫');
-- 10
</code></pre>
<h3 id="trim-ltrim-rtrim"><a class="header" href="#trim-ltrim-rtrim">TRIM, LTRIM, RTRIM</a></h3>
<p>The <code>TRIM</code>, <code>LTRIM</code>, and <code>RTRIM</code> functions trim surrounding whitespace,
whitespace to the left, and whitespace to the right of a string, respectively.</p>
<pre><code class="language-sql">SELECT TRIM('  hello  ');
-- 'hello'

SELECT LTRIM('  hello  ');
-- 'hello  '

SELECT RTRIM('  hello  ');
-- '  hello'
</code></pre>
<h3 id="lower-upper"><a class="header" href="#lower-upper">LOWER, UPPER</a></h3>
<p>The <code>LOWER</code> and <code>UPPER</code> functions downcase and upcase a string, respectively.</p>
<pre><code class="language-sql">SELECT LOWER('Relatable Algebra');
-- 'relatable algebra'

SELECT UPPER('Shouting Calculus');
-- 'SHOUTING CALCULUS'
</code></pre>
<h3 id="replace"><a class="header" href="#replace">REPLACE</a></h3>
<p>The <code>REPLACE</code> function returns the string in the first parameter,
with the second parameter (if found) replaced by the third.</p>
<pre><code class="language-sql">SELECT REPLACE('Relatable Algebra', 'Rela', 'Infla');
</code></pre>
<h3 id="instr"><a class="header" href="#instr">INSTR</a></h3>
<p>The <code>INSTR</code> function returns the first character of a substring match on the second parameter,
if found, and <code>0</code> if it is not found.</p>
<pre><code class="language-sql">SELECT INSTR('Coffee', 'ee');
</code></pre>
<h3 id="substring"><a class="header" href="#substring">SUBSTRING</a></h3>
<p>The <code>SUBSTRING</code> function returns the substring starting from the index provided as the second parameter.
If the (optional) third parameter is provided, the substring will be of that length (or less, if the end of the source string is reached).
<code>SUBSTR</code> is a synonym for <code>SUBSTRING</code>.</p>
<pre><code class="language-sql">SELECT SUBSTRING('Hello Edgar', 4);
SELECT SUBSTR('Hello Edgar', 4, 2);
</code></pre>
<h3 id="position"><a class="header" href="#position">POSITION</a></h3>
<p>The <code>POSITION</code> pseudo-function returns the first position of the first character of the first matched substring
in another string.
If the substring is not detected, <code>POSITION</code> returns <code>0</code>.</p>
<pre><code class="language-sql">SELECT POSITION(&quot;h&quot; IN &quot;Hawaii&quot;);
SELECT POSITION(&quot;i&quot; IN &quot;Hawaii&quot;);
SELECT POSITION(&quot;Ha&quot; IN &quot;Hawaii&quot;);
</code></pre>
<p>NOTE: <code>POSITION</code> is a &quot;pseudo-function&quot; because internally it uses custom syntax of the form
<code>&lt;substring&gt; IN &lt;string&gt;</code>.</p>
<h3 id="unicode"><a class="header" href="#unicode">UNICODE</a></h3>
<p>The <code>UNICODE</code> function returns an integer unicode value for the first character
of the parameter given.</p>
<pre><code class="language-sql">SELECT UNICODE('Adam');
</code></pre>
<h3 id="char"><a class="header" href="#char">CHAR</a></h3>
<p>The <code>CHAR</code> function returns a string corresponding to the supplied integer
character codes.</p>
<pre><code class="language-sql">SELECT CHAR(65, 66, 67);
</code></pre>
<h3 id="concat"><a class="header" href="#concat">CONCAT</a></h3>
<p><code>CONCAT</code> is equivalent to the <a href="sql/operators.html#concatenation">Concatenation Operator (||)</a>
except that <code>CONCAT</code> is limited to 2-arity applications and <code>||</code> can be chained.</p>
<h3 id="like-1"><a class="header" href="#like-1">LIKE</a></h3>
<p>The <code>LIKE</code> function serves the same purpose as the
<a href="sql/operators.html#like"><code>LIKE</code> operator</a>.
However, the argument order is (effectively) reversed for the <code>LIKE</code> function,
to match the signature used in SQLite.
For the function version, the pattern is the first argument.
Optionally, an alternative escape character can be provided as a third argument.</p>
<pre><code class="language-sql">SELECT * FROM users WHERE LIKE('Stev%', name);
SELECT * FROM users WHERE LIKE('EdgarX%', name, 'X');
</code></pre>
<h2 id="collection-functions"><a class="header" href="#collection-functions">Collection Functions</a></h2>
<h3 id="length"><a class="header" href="#length">LENGTH</a></h3>
<p>The <code>LENGTH</code> function counts the number of entries in a collection.
When supplied with a string, it is a synonym for <code>CHARACTER_LENGTH</code>.</p>
<pre><code class="language-sql">SELECT LENGTH([3, 2]);
SELECT LENGTH({name: 'Peas', price: 8.99, product_no: 77});
SELECT LENGTH('josé');
</code></pre>
<p>NOTE: <code>CARDINALITY</code> is an synonym for <code>LENGTH</code>.</p>
<h3 id="unnest"><a class="header" href="#unnest">UNNEST</a></h3>
<p>The <code>UNNEST</code> function can be thought of as the inverse of
<a href="sql/functions.html#array_agg"><code>ARRAY_AGG</code></a>,
although it offers more power than just unlinking elements.
It takes an array or object and pulls its elements into separate rows.</p>
<pre><code class="language-sql">SELECT * FROM UNNEST([1.99, 2.99, 3.99]) AS products(price);
</code></pre>
<p>It is possible to unnest multiple arrays.
If the arrays do not have the same number of elements, the shorter array(s) will
have those values filled with <code>NULL</code>:</p>
<pre><code class="language-sql">SELECT names.* FROM (VALUES (['Leslie', 'Edgar', 'fiver2'], ['Lamport', 'Codd'])) AS x(first, last), UNNEST(x.first, x.last) AS names(first, last);
</code></pre>
<p>When unnesting an object, keys-value pairs will be returned
as per <a href="sql/functions.html#object_entries">object_entries</a>.
This behaviour is useful for manipulating collections:</p>
<pre><code class="language-sql">SELECT * FROM UNNEST({original_price: 1.99, sale_price: 1.50, coupon_price: 1.40}) AS prices(price);
-- [{'price': ['sale_price', 1.5]},
--  {'price': ['coupon_price', 1.4]},
--  {'price': ['original_price', 1.99]}]
</code></pre>
<h4 id="with-ordinality"><a class="header" href="#with-ordinality">WITH ORDINALITY</a></h4>
<p><code>UNNEST</code> can be suffixed with <code>WITH ORDINALITY</code>
to append an ordinal column to the results.</p>
<pre><code class="language-sql">SELECT * FROM UNNEST([1.99, 2.99, 3.99]) WITH ORDINALITY AS products(price, n);
-- [{'n': 0, 'price': 1.99}, {'n': 1, 'price': 2.99}, {'n': 2, 'price': 3.99}]
</code></pre>
<p>NOTE: Endb ordinals are zero-indexed.</p>
<h3 id="object_keys"><a class="header" href="#object_keys">OBJECT_KEYS</a></h3>
<p>An object's keys can be selected using <code>OBJECT_KEYS</code>.</p>
<pre><code class="language-sql">SELECT OBJECT_KEYS({original_price: 1.99, sale_price: 1.50, coupon_price: 1.40});
</code></pre>
<h3 id="object_values"><a class="header" href="#object_values">OBJECT_VALUES</a></h3>
<p>An object's values can be selected using <code>OBJECT_VALUES</code>.</p>
<pre><code class="language-sql">SELECT OBJECT_VALUES({original_price: 1.99, sale_price: 1.50, coupon_price: 1.40});
</code></pre>
<h3 id="object_entries"><a class="header" href="#object_entries">OBJECT_ENTRIES</a></h3>
<p>Returns an array of key-value pairs representing the given object.</p>
<pre><code class="language-sql">SELECT OBJECT_ENTRIES({a: 1, b: 2, c: 3});
-- [['a': 1], ['b': 2], ['c': 3]]
</code></pre>
<h3 id="object_from_entries"><a class="header" href="#object_from_entries">OBJECT_FROM_ENTRIES</a></h3>
<p>Constructs an object from an array of key-value pairs.</p>
<pre><code class="language-sql">SELECT OBJECT_FROM_ENTRIES([['a', 1], ['b', 2], ['c', 3]]);
-- {a: 1, b: 2, c: 3}
</code></pre>
<h3 id="patch"><a class="header" href="#patch">PATCH</a></h3>
<p>The <code>PATCH</code> function takes two documents.
The document returned is the first document &quot;patched&quot; with any fields found in the second document.
If the second document does not specify a field, that field is left untouched.
If the second document specifies any fields with values of <code>NULL</code>, those fields are removed.</p>
<pre><code class="language-sql">SELECT PATCH(
  {name: 'Salt', nutrition: {sodium: 100, ingredients: 'Kosher Salt'}},
  {name: 'Sea Salt', nutrition: {ingredients: NULL}}
);
</code></pre>
<p>The <code>PATCH</code> function has an equivalent operator for data manipulation:
<a href="sql/data_manipulation.html#update-patch"><code>UPDATE PATCH</code></a></p>
<h2 id="numeric-functions"><a class="header" href="#numeric-functions">Numeric Functions</a></h2>
<h3 id="random"><a class="header" href="#random">RANDOM</a></h3>
<p>The <code>RANDOM</code> function returns a random integer.</p>
<pre><code class="language-sql">SELECT RANDOM();
</code></pre>
<h3 id="generate_series"><a class="header" href="#generate_series">GENERATE_SERIES</a></h3>
<p>The <code>GENERATE_SERIES</code> function generates an array of numbers within a given interval.
The first and second parameters are the start and end of the interval.
The optional third parameter is a step value by which to increment each number.
The result is returned as a single anonymous column (with the default name, <code>column1</code>)
containing the array.</p>
<pre><code class="language-sql">SELECT GENERATE_SERIES(0, 21);
SELECT GENERATE_SERIES(0, 21, 3);
</code></pre>
<p>It is possible to use the result of <code>GENERATE_SERIES</code> in other SQL expressions, like <code>IN</code>:</p>
<pre><code class="language-sql">SELECT * FROM products WHERE product_no IN (SELECT column1 FROM generate_series(1000, 20000) AS foo);
</code></pre>
<h3 id="math-1"><a class="header" href="#math-1">Math</a></h3>
<p>Endb provides standard SQL math functions based on SQLite's collection of math functions:</p>
<ul>
<li>ROUND</li>
<li>SIN</li>
<li>COS</li>
<li>TAN</li>
<li>SINH</li>
<li>COSH</li>
<li>TANH</li>
<li>ASIN</li>
<li>ACOS</li>
<li>ATAN</li>
<li>ASINH</li>
<li>ACOSH</li>
<li>ATANH</li>
<li>ATAN2</li>
<li>FLOOR</li>
<li>CEILING, CEIL</li>
<li>SIGN</li>
<li>SQRT</li>
<li>EXP</li>
<li>POWER, POW</li>
<li>LOG, LOG10</li>
<li>LOG2</li>
<li>LN</li>
<li>DEGREES</li>
<li>RADIANS</li>
<li>PI</li>
<li>ABS</li>
</ul>
<p>NOTE: Endb follows the choice of most SQL databases and aliases <code>LOG</code> to <code>LOG10</code>
rather than <code>LN</code> (natural log), as specified by the SQL standard.</p>
<p>NOTE: Mathematical operators are documented under <a href="sql/operators.html#math">Operators</a>.</p>
<h2 id="datetime-functions"><a class="header" href="#datetime-functions">Date/Time Functions</a></h2>
<h3 id="strftime"><a class="header" href="#strftime">STRFTIME</a></h3>
<p>The <code>STRFTIME</code> function formats a date or time value as a string.</p>
<pre><code class="language-sql">SELECT strftime('%Y/%m/%d', date('2001-01-01'));
SELECT strftime('%Y %m %d at %H %M %S', datetime('2001-01-01 03:04:05'));
</code></pre>
<h3 id="unixepoch"><a class="header" href="#unixepoch">UNIXEPOCH</a></h3>
<p>The <code>UNIXEPOCH</code> function returns the number of seconds since the UNIX epoch.
Accepts a <code>DATE</code>, <code>TIMESTAMP</code>, or <code>STRING</code>.</p>
<pre><code class="language-sql">SELECT UNIXEPOCH('2023-01-01');
SELECT UNIXEPOCH(1970-01-01T00:00:00Z);
</code></pre>
<h3 id="julianday"><a class="header" href="#julianday">JULIANDAY</a></h3>
<p>The <code>JULIANDAY</code> function returns the Julian Day, which is the number of days since
noon in UTC on November 24, 4714 B.C.
Accepts a <code>DATE</code>, <code>TIMESTAMP</code>, or <code>STRING</code>.</p>
<pre><code class="language-sql">SELECT JULIANDAY(1970-01-01);
</code></pre>
<h3 id="extract"><a class="header" href="#extract">EXTRACT</a></h3>
<p>The <code>EXTRACT</code> pseudo-function provides a way to access one named, numerical portion of a
date, time, or timestamp.
Portions of dates can only be extracted from dates or timestamps.
Portions of times can only be extracted from timestamps or times.</p>
<pre><code class="language-sql">SELECT EXTRACT(YEAR FROM CURRENT_DATE);
SELECT EXTRACT(MONTH FROM CURRENT_DATE);
SELECT EXTRACT(DAY FROM CURRENT_TIMESTAMP);
SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);
SELECT EXTRACT(MINUTE FROM CURRENT_TIME);
SELECT EXTRACT(SECOND FROM CURRENT_TIME);
</code></pre>
<p>NOTE: <code>EXTRACT</code> is a &quot;pseudo-function&quot; because internally it uses custom syntax of the form
<code>&lt;named-portion&gt; FROM &lt;date&gt;</code>.</p>
<h2 id="aggregate-functions"><a class="header" href="#aggregate-functions">Aggregate Functions</a></h2>
<h3 id="min-max"><a class="header" href="#min-max">MIN, MAX</a></h3>
<p>The <code>MIN</code> and <code>MAX</code> functions return the minimum and maximum values for an expression,
respectively.</p>
<pre><code class="language-sql">SELECT MIN(price) FROM products;
SELECT MAX(price) FROM products;
</code></pre>
<p>NOTE: <code>MIN</code> and <code>MAX</code> also have non-aggregate equivalents, which are 2-arity.
When used that way, they each return the minimum or maximum value of the two values provided.</p>
<h3 id="sum"><a class="header" href="#sum">SUM</a></h3>
<p>The <code>SUM</code> function returns the sum of all non-null values under the column given as a parameter.</p>
<pre><code class="language-sql">SELECT SUM(price) FROM products;
</code></pre>
<p>If all values for the given column are <code>NULL</code>, <code>SUM</code> returns <code>NULL</code>.</p>
<h3 id="total"><a class="header" href="#total">TOTAL</a></h3>
<p>The <code>TOTAL</code> function is equivalent to <code>SUM</code> except that it returns <code>0.0</code> in the case where
all input values are <code>NULL</code>.</p>
<h3 id="avg"><a class="header" href="#avg">AVG</a></h3>
<p>The <code>AVG</code> function takes a numerical-type-agnostic average of all values under the
column given as a parameter.</p>
<pre><code class="language-sql">SELECT AVG(price) FROM products;
</code></pre>
<h3 id="count"><a class="header" href="#count">COUNT</a></h3>
<p>The <code>COUNT</code> function returns the count of <em>non-null</em>, <em>non-empty</em> values for the specified column.</p>
<pre><code>SELECT COUNT(price) FROM sales;
</code></pre>
<p>NOTE: Because null/empty values are ignored, the behaviour of <code>COUNT</code> will differ from other
SQL dialects. Whether or not <code>COUNT(price)</code> and <code>COUNT(1)</code> are equivalent is dependent on
whether the <code>price</code> attribute exists with a non-null value on each document.</p>
<h3 id="array_agg"><a class="header" href="#array_agg">ARRAY_AGG</a></h3>
<p>The <code>ARRAY_AGG</code> function concatenates the results of an expression into an array.
The parameter may be <a href="sql/queries.html#order-by-sorting-results">ordered</a>
within <code>ARRAY_AGG</code>.</p>
<pre><code class="language-sql">SELECT ARRAY_AGG(price) FROM products;
SELECT ARRAY_AGG(name ORDER BY price DESC) FROM products;
</code></pre>
<p>Note that when operating on arrays, the arrays themselves will be concatenated,
not the contents of the arrays.
The result will be an array of one higher dimension:</p>
<pre><code class="language-sql">SELECT ARRAY_AGG(x.column1) FROM (VALUES ([1,2]), ([3,4])) AS x;
-- [{'column1': [[1, 2], [3, 4]]}]
</code></pre>
<h3 id="group_concat"><a class="header" href="#group_concat">GROUP_CONCAT</a></h3>
<p>The <code>GROUP_CONCAT</code> function returns a string with concatenated
non-null values from a column or group.
Given a second parameter,
It defaults to a comma-delimited list, but the second (optional) parameter
can override the delimiter.</p>
<pre><code class="language-sql">SELECT GROUP_CONCAT(name) FROM products;
SELECT GROUP_CONCAT(name, ':') FROM products;
</code></pre>
<h3 id="filter"><a class="header" href="#filter">FILTER</a></h3>
<p>All aggregate functions can have a filter applied before aggregation.</p>
<pre><code class="language-sql">SELECT SUM(price) FILTER(WHERE price &gt; 20) FROM products;
</code></pre>
<h2 id="data-type-functions"><a class="header" href="#data-type-functions">Data Type Functions</a></h2>
<h3 id="cast"><a class="header" href="#cast">CAST</a></h3>
<p>The <code>CAST</code> function forces a value into a particular data type.
Note that not all types are cast-compatible with each other.</p>
<pre><code class="language-sql">SELECT CAST(price AS INTEGER) FROM products;
</code></pre>
<h3 id="typeof"><a class="header" href="#typeof">TYPEOF</a></h3>
<p>The <code>TYPEOF</code> function returns the type of the provided value.</p>
<pre><code class="language-sql">SELECT TYPEOF('hi2u');
SELECT TYPEOF(1.12345678901234);
SELECT TYPEOF(2018-01-01T00:00:00);
</code></pre>
<h2 id="conditional-functions"><a class="header" href="#conditional-functions">Conditional Functions</a></h2>
<h3 id="iif"><a class="header" href="#iif">IIF</a></h3>
<p>The <code>IIF</code> function is a conditional shorthand.
It returns the second parameter if the condition is true and the third parameter if the condition is false.</p>
<pre><code class="language-sql">SELECT IIF(price &gt; 5.99, 'Expensive!', 'Cheap') FROM products;
</code></pre>
<h3 id="nullif"><a class="header" href="#nullif">NULLIF</a></h3>
<p>The <code>NULLIF</code> function returns <code>TRUE</code> if the two supplied expressions are equal.</p>
<pre><code class="language-sql">SELECT NULLIF(1, 1);
SELECT NULLIF(1, 'zig');
</code></pre>
<h3 id="coalesce"><a class="header" href="#coalesce">COALESCE</a></h3>
<p>The <code>COALESCE</code> function returns its first non-null argument.
The following example returns <code>'zig'</code>:</p>
<pre><code class="language-sql">SELECT COALESCE(NULL, NULL, 'zig', 'zag');
</code></pre>
<h2 id="encoding-functions"><a class="header" href="#encoding-functions">Encoding Functions</a></h2>
<h3 id="base64"><a class="header" href="#base64">BASE64</a></h3>
<p>The <code>BASE64</code> function takes a hexadecimal-encoded BLOB and returns a base64-encoded string, or vice-versa.
<code>BASE64</code> roundtrips its own data.
There is therefore no <code>BLOBFROMBASE64</code> function.</p>
<pre><code class="language-sql">SELECT BASE64(x'010203');
SELECT BASE64('AQID');
</code></pre>
<h3 id="uuid"><a class="header" href="#uuid">UUID</a></h3>
<p>The <code>UUID</code> function returns a universally-unique identifier, as a string.
The <code>UUID_BLOB</code> function takes a string UUID and returns a BLOB.
The <code>UUID_STR</code> function takes a BLOB UUID and returns a string.
When given a parameter of their return type, <code>UUID_BLOB</code> and <code>UUID_STR</code> will format the UUID provided.</p>
<pre><code class="language-sql">SELECT UUID();
SELECT UUID_BLOB('d2ce21c9-d268-409a-b1e0-49e1200bfa47');
SELECT UUID_STR(x'd2ce21c9d268409ab1e049e1200bfa47');

-- formatting:
SELECT UUID_BLOB(x'd2ce21c9d268409ab1e049e1200bfa47');
SELECT UUID_STR('d2ce21c9d268409ab1e049e1200bfa47');
</code></pre>
<h3 id="sha1"><a class="header" href="#sha1">SHA1</a></h3>
<p>The <code>SHA1</code> function takes either a hexadecimal-encoded BLOB, a string, or a number.
It returns the SHA-1 encoding of that value.</p>
<pre><code class="language-sql">SELECT SHA1('2');
</code></pre>
<h3 id="randomblob-zeroblob"><a class="header" href="#randomblob-zeroblob">RANDOMBLOB, ZEROBLOB</a></h3>
<p>The <code>RANDOMBLOB</code> function returns a random binary large object of the size given, in bytes.
The <code>ZEROBLOB</code> function returns a zeroed-out binary large object of the size given, in bytes.</p>
<pre><code class="language-sql">SELECT RANDOMBLOB(32);
SELECT ZEROBLOB(32);
</code></pre>
<h3 id="hex-unhex"><a class="header" href="#hex-unhex">HEX, UNHEX</a></h3>
<p>The <code>HEX</code> function takes a BLOB (or coerces its argument into a UTF-8 string,
which in turn is interpreted as a BLOB)
and turns the BLOB into an upper-case hexadecimal string.</p>
<p>The <code>UNHEX</code> function takes a hexadecimal string and turns it into a BLOB.
The hexadecimal string provided must contain <em>character pairs</em>.
<code>UNHEX</code> takes an optional second parameter: a string containing non-hexadecimal
characters to be ignored in the first parameter.
If non-hexadecimal characters are found in the first parameter but not ignored
in the second parameter, <code>UNHEX</code> returns <code>NULL</code>.</p>
<pre><code class="language-sql">SELECT HEX(15);
-- '3135'

SELECT UNHEX('3135');
-- b'15'

SELECT UNHEX('3135ZZ', 'Z');
-- b'15'

SELECT UNHEX('3135ZZ', 'M');
-- NULL
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-queries"><a class="header" href="#time-queries">Time Queries</a></h1>
<p>To make best use of Time Queries, it is a good idea to review the
time-related SQL data types, such as <code>TIMESTAMP</code>, <code>DATE</code>, <code>TIME</code>,
and <code>INTERVAL</code>.
These are covered in the <a href="sql/data_types.html">SQL Data Types</a> section.</p>
<p>It is also a good idea to review Endb's other time-related functions,
in case they are helpful to you:</p>
<ul>
<li><a href="sql/functions.html#strftime"><code>STRFTIME</code></a></li>
<li><a href="sql/functions.html#unixepoch"><code>UNIXEPOCH</code></a></li>
<li><a href="sql/functions.html#julianday"><code>JULIANDAY</code></a></li>
</ul>
<h2 id="note-on-sql2011-closed-open-period-model"><a class="header" href="#note-on-sql2011-closed-open-period-model">Note on SQL:2011 closed-open period model</a></h2>
<p>All Endb temporal predicates (<code>CONTAINS</code>, <code>OVERLAPS</code>, <code>PRECEDES</code>,
<code>SUCCEEDS</code>, <code>IMMEDIATELY PRECEDES</code>, and <code>IMMEDIATELY SUCCEEDS</code>)
follow the SQL:2011 standard's &quot;closed-open period model&quot;.
This means that a period represents all times starting from (and including)
the start time up to (but excluding) the end time.</p>
<h2 id="note-on-timezones-1"><a class="header" href="#note-on-timezones-1">Note on timezones</a></h2>
<p>Endb currently only supports times encoded as UTC.</p>
<h2 id="now"><a class="header" href="#now">Now</a></h2>
<p>Endb provides access to the current value of the clock &quot;now&quot;
in multiple date/time configurations.</p>
<h3 id="current_timestamp"><a class="header" href="#current_timestamp">CURRENT_TIMESTAMP</a></h3>
<p><code>CURRENT_TIMESTAMP</code> gets the current date and time in UTC.</p>
<pre><code class="language-sql">SELECT CURRENT_TIMESTAMP;
</code></pre>
<h3 id="current_time"><a class="header" href="#current_time">CURRENT_TIME</a></h3>
<p><code>CURRENT_TIME</code> gets the current time in UTC.</p>
<pre><code class="language-sql">SELECT CURRENT_TIME;
</code></pre>
<h3 id="current_date"><a class="header" href="#current_date">CURRENT_DATE</a></h3>
<p><code>CURRENT_DATE</code> gets the current date in UTC.
Note that this may be different from your <em>local</em> date,
depending on the time of day when your query is run.</p>
<pre><code class="language-sql">SELECT CURRENT_DATE;
</code></pre>
<h2 id="system-time"><a class="header" href="#system-time">System Time</a></h2>
<p>All states an Endb database has ever seen are recorded, immutably.
Accessing these prior states is accomplished by querying System Time.
System Time is encoded in a special column, which is normally invisible to most queries,
named <code>SYSTEM_TIME</code>.</p>
<h3 id="as-of-time-travel"><a class="header" href="#as-of-time-travel">AS OF (Time Travel)</a></h3>
<p>Endb permits time-traveling queries with the SQL:2011-compatible
<code>AS OF</code> operator.
The query will treat the <code>DATE</code> or <code>TIMESTAMP</code> supplied after <code>AS OF</code>
as if it were that time <em>now</em>.</p>
<pre><code class="language-sql">SELECT * FROM products FOR SYSTEM_TIME AS OF 2023-08-25T00:00:00;
</code></pre>
<h3 id="all-time-omniscience"><a class="header" href="#all-time-omniscience">ALL (Time Omniscience)</a></h3>
<p>Endb permits time-omniscient queries with the SQL:2011-compatible
<code>ALL</code> operator.
All states, across the entire history of the relevant tables, are
visible to a query suffixed with <code>FOR SYSTEM_TIME ALL</code>:</p>
<pre><code class="language-sql">SELECT * FROM products FOR SYSTEM_TIME ALL;
</code></pre>
<h3 id="between-1"><a class="header" href="#between-1">BETWEEN</a></h3>
<p>The syntax for time-aware <code>BETWEEN</code> is the same as the
<a href="sql/operators.html#between">normal <code>BETWEEN</code> operator</a>.
Inspect System Time with the form <code>FOR SYSTEM_TIME BETWEEN x AND y</code>.</p>
<pre><code class="language-sql">SELECT * FROM products FOR SYSTEM_TIME BETWEEN 2023-08-24T00:00:00 AND 2023-08-25T00:00:00;
</code></pre>
<h3 id="from--to"><a class="header" href="#from--to">FROM ... TO</a></h3>
<p>Selects rows which fall between the two times, similar to <code>BETWEEN</code>,
but is exclusive of both the start and end times.</p>
<pre><code class="language-sql">SELECT * FROM products FOR SYSTEM_TIME FROM 2023-08-24T00:00:00 TO 2023-08-30T00:00:00;
</code></pre>
<h2 id="period-predicates"><a class="header" href="#period-predicates">Period Predicates</a></h2>
<p>The standard SQL:2011 period predicates are available.</p>
<h3 id="contains"><a class="header" href="#contains">CONTAINS</a></h3>
<p>Returns <code>TRUE</code> if the second period is contained within the first.</p>
<pre><code class="language-sql">SELECT {start: 2001-01-01, end: 2001-04-01} CONTAINS {start: 2001-02-01, end: 2001-04-01};
</code></pre>
<h3 id="overlaps"><a class="header" href="#overlaps">OVERLAPS</a></h3>
<p>Returns <code>TRUE</code> if any part of the first period is found within the second.</p>
<pre><code class="language-sql">SELECT {start: 2001-01-01, end: 2001-03-01} OVERLAPS {start: 2001-02-01, end: 2001-04-01};
</code></pre>
<h3 id="precedes"><a class="header" href="#precedes">PRECEDES</a></h3>
<p>Returns <code>TRUE</code> if the first period ends before the second period begins.</p>
<pre><code class="language-sql">SELECT 2001-03-01 PRECEDES [2001-04-01T00:00:00Z, 2001-05-01];
</code></pre>
<h3 id="succeeds"><a class="header" href="#succeeds">SUCCEEDS</a></h3>
<p>Returns <code>TRUE</code> if the first period begins after the second period ends.</p>
<pre><code class="language-sql">SELECT 2001-06-01 SUCCEEDS [2001-04-01T00:00:00Z, 2001-05-01];
</code></pre>
<h3 id="immediately-precedes"><a class="header" href="#immediately-precedes">IMMEDIATELY PRECEDES</a></h3>
<p>Returns <code>TRUE</code> if the first period ends exactly as the second period begins.</p>
<pre><code class="language-sql">SELECT 2001-04-01 IMMEDIATELY PRECEDES [2001-04-01T00:00:00Z, 2001-05-01];
</code></pre>
<h3 id="immediately-succeeds"><a class="header" href="#immediately-succeeds">IMMEDIATELY SUCCEEDS</a></h3>
<p>Returns <code>TRUE</code> if the first period begins exactly as the second period ends.</p>
<pre><code class="language-sql">SELECT 2001-05-01 IMMEDIATELY SUCCEEDS [2001-04-01T00:00:00Z, 2001-05-01];
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-navigation"><a class="header" href="#path-navigation">Path Navigation</a></h1>
<p>Because Endb is schemaless and semi-structured, it
offers a number of powerful path-nativation primitives
inspired by
<a href="https://datatracker.ietf.org/doc/draft-ietf-jsonpath-base/">JSONPath</a>,
<a href="https://www.iso.org/standard/78937.html">SQL/JSON</a>,
and their derivatives in legacy relational databases.</p>
<p>You will want to familiarize yourself with Endb's
<a href="sql/data_types.html">nested data types</a> (arrays and objects)
before learning about path navigation.</p>
<p>In the examples below, path examples are shown in the <code>SELECT</code> clause,
but they are also valid in the <code>WHERE</code> clause.</p>
<h2 id="nested-objects"><a class="header" href="#nested-objects">Nested Objects</a></h2>
<p>If you are familiar with arrays and objects, try adding
some nested objects to the table <code>paths</code> (the table name is arbitrary).</p>
<pre><code class="language-sql">INSERT INTO paths {a: 2, b: {a: 3}, c: [{a: 1}, 2]};
</code></pre>
<h2 id="root-navigation"><a class="header" href="#root-navigation">Root Navigation</a></h2>
<p>Navigating the root of any document (row) as a tree looks
like standard SQL, because it is:</p>
<pre><code class="language-sql">SELECT a FROM paths;
</code></pre>
<p>Similarly, however, it is possible to navigate documents
listed in an array:</p>
<pre><code class="language-sql">SELECT [{a: 2}, {a: 3}, {b: 4}].a;
-- [{'a': [2, 3]}]
</code></pre>
<p>It is also possible to navigate fields of sub-documents
(columns of nested rows) with further dot notation:</p>
<pre><code class="language-sql">SELECT b.a FROM paths;
-- [{'a': 3}]
</code></pre>
<h2 id="row-literals-1"><a class="header" href="#row-literals-1">Row Literals</a></h2>
<p>It is possible (and helpful) to create a row literal to
represent rows returned, so they are easier to navigate.
The format of a row literal is <code>{ &lt;table&gt;.* }</code>:</p>
<pre><code class="language-sql">SELECT { paths.* } FROM paths;
</code></pre>
<p>See <a href="sql/data_types.html#row-literals">Row Literal Data Type</a></p>
<h2 id="recursive-paths"><a class="header" href="#recursive-paths">Recursive Paths</a></h2>
<p>The double dot (<code>..</code>) notation performs a &quot;deep scan&quot; by
recursively walking the document to match the name given.</p>
<pre><code class="language-sql">SELECT { paths.* }..a FROM paths;
-- [{'a': [2, 3, 1]}]

SELECT b..a FROM paths;
-- [{'a': [3]}]
</code></pre>
<h2 id="named-child"><a class="header" href="#named-child">Named Child</a></h2>
<p>The square bracket notation (<code>['&lt;NAME&gt;']</code>) performs a lookup
of a single descendent child.</p>
<pre><code class="language-sql">SELECT { paths.* }['b']['a'] FROM paths;
-- [{'a': 3}]

SELECT b['a'] FROM paths;
-- [{'a': 3}]
</code></pre>
<p>Named Children can be combined with recursive paths,
though the default recursive path syntax is synonymous with
named children:</p>
<pre><code class="language-sql">SELECT { paths.* }..a FROM paths;
SELECT { paths.* }..['a'] FROM paths;
SELECT b..['a'] FROM paths;
</code></pre>
<h2 id="numbered-child"><a class="header" href="#numbered-child">Numbered Child</a></h2>
<p>The square bracket notation (<code>[&lt;NUMBER&gt;]</code>) can also perform indexed
lookups of a single descendent child.</p>
<pre><code class="language-sql">SELECT { paths.* }['b'][0] FROM paths;
-- [{'column1': {'a': 3}}]

SELECT { paths.* }['c'][1] FROM paths;
-- [{'column1': 2}]

SELECT c[1] FROM paths;
-- [{'column1': 2}]
</code></pre>
<p>Numbered Children can be combined with recursive paths.
This finds and returns all indexed values, counting backward:</p>
<pre><code class="language-sql">SELECT { paths.* }..[-1] FROM paths;
-- [{'column1': [2]}]
</code></pre>
<h2 id="wildcard-child"><a class="header" href="#wildcard-child">Wildcard Child</a></h2>
<p>The square bracket notation (<code>[*]</code>) can also perform a wildcard
lookup of all descendent children.</p>
<pre><code class="language-sql">SELECT [{a: 2}, {a: 3}, {b: 4}, 5][*];
</code></pre>
<p>Wildcards can be combined with recursive paths.
This finds and returns <em>all</em> values:</p>
<pre><code class="language-sql">SELECT { paths.* }..[*] FROM paths;
-- [{'column1': [2, {'a': 3}, [{'a': 1}, 2], 3, {'a': 1}, 2, 1]}]

SELECT c..[*] FROM paths;
-- [{'column1': [{'a': 1}, 2, 1]}]
</code></pre>
<h2 id="path-functions"><a class="header" href="#path-functions">Path Functions</a></h2>
<p>Path editing is accomplished with an extended path syntax, where each
path begins with <code>$</code>.</p>
<p>Endb's path editing functions are heavily inspired by
<a href="https://www.sqlite.org/json1.html">SQLite's JSON Functions</a>.</p>
<p>Path editing functions add functionality (<code>$</code>, <code>#</code>) to a subset
Endb's normal path navigation syntax:
path editing functions do not support recursion or wildcards.</p>
<p>Path editing functions are available to
<a href="sql/data_manipulation.html#update-set-path"><code>UPDATE ... SET</code></a> and
<a href="sql/data_manipulation.html#update-unset-path"><code>UPDATE ... UNSET/REMOVE</code></a>.</p>
<h3 id="path_set"><a class="header" href="#path_set"><code>path_set</code></a></h3>
<p>Takes an object, a path, and a new value.
The new value will overwrite existing fields or add a new field if it
doesn't already exist.</p>
<pre><code class="language-sql">SELECT path_set({a: 2, c: 4}, $.c, [97,96]);
-- {'a': 2, 'c': [97, 96]}
</code></pre>
<h3 id="path_replace"><a class="header" href="#path_replace"><code>path_replace</code></a></h3>
<p>Takes an object, a path, and a new value.
The new value is ignored if the path does not match an existing field.</p>
<pre><code class="language-sql">SELECT path_replace({a: 2, c: 4}, $.a, 99);
-- {'a': 99, 'c': 4}

SELECT path_replace({a: 2, c: 4}, $.e, 99);
-- {'a': 2, 'c': 4}
</code></pre>
<h3 id="path_insert"><a class="header" href="#path_insert"><code>path_insert</code></a></h3>
<p>Takes an object, a path, and a new value.
The new value is ignored if the path matches an existing field.</p>
<pre><code class="language-sql">SELECT path_insert({a: 2, c: 4}, $.e, 99);
-- {'a': 2, 'c': 4, 'e': 99}
</code></pre>
<h3 id="path_remove"><a class="header" href="#path_remove"><code>path_remove</code></a></h3>
<p>Takes an object and a variable number of arguments specifying which paths to remove.
If a path is not found, nothing is removed for that argument.
<code>#</code> represents the last element in a collection.</p>
<pre><code class="language-sql">SELECT path_remove([0,1,2,3,4], $[#-1], $[0]);
-- [1, 2, 3]

SELECT path_remove({x: 25, y: 42}, $.y);
-- {'x': 25}
</code></pre>
<h3 id="path_extract"><a class="header" href="#path_extract"><code>path_extract</code></a></h3>
<p>Takes an object and a variable number of path arguments.
Returns the value found at each path, if any, otherwise <code>NULL</code>.
If only a single path is provided, a scalar is returned.
If multiple paths are provided, an array is returned.</p>
<pre><code class="language-sql">SELECT path_extract({a: 2, c: [4, 5, {f: 7}]}, $.c[2].f);
-- 7

SELECT path_extract({a: 2, c: [4, 5], f: 7}, $.x, $.a);
-- [NULL, 2]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema"><a class="header" href="#schema">Schema</a></h1>
<p>Endb allows introspection of its information schema.
The Endb information schema does <em>not</em> describe the structure of
each table.
Because Endb is a document database, each document (row) is responsible
for its own schema.
The information schema is used by Endb to describe database objects
at a high level and is used for schemaless queries, such as <code>SELECT *</code>.</p>
<p>Note that all information schema tables are hard-coded to
lower-case names and must be queried as such.</p>
<h2 id="tables"><a class="header" href="#tables">Tables</a></h2>
<pre><code>-&gt; SELECT * FROM information_schema.tables;
[{'table_catalog': None,
  'table_name': 'stores',
  'table_schema': 'main',
  'table_type': 'BASE TABLE'},
 {...
  'table_name': 'products',
  ... },
 {...
  'table_name': 'sales',
  ... }]
</code></pre>
<h2 id="columns"><a class="header" href="#columns">Columns</a></h2>
<pre><code>-&gt; SELECT * FROM information_schema.columns;
[{'column_name': 'addresses',
  'ordinal_position': 0,
  'table_catalog': None,
  'table_name': 'stores',
  'table_schema': 'main'},
 {'column_name': 'brand',
  ... },
 {'column_name': 'price',
  ... },
 ... ]
</code></pre>
<h2 id="views"><a class="header" href="#views">Views</a></h2>
<pre><code>-&gt; SELECT * FROM information_schema.views;
[{'table_catalog': None,
  'table_name': 'sold_products',
  'table_schema': 'main',
  'view_definition': 'SELECT * FROM products p JOIN sales s ON p.id = s.p_id'}]
</code></pre>
<h2 id="check-constraints"><a class="header" href="#check-constraints">Check Constraints</a></h2>
<p>The <code>check_constraints</code> table in Endb is used to store <a href="sql/assertions.html">assertions</a>.</p>
<pre><code>-&gt; SELECT * FROM information_schema.check_constraints;
[{'check_clause': &quot;(NOT EXISTS (SELECT * FROM users WHERE TYPEOF(email) != 'text'))&quot;,
  'constraint_catalog': None,
  'constraint_name': 'string_email',
  'constraint_schema': 'main'}]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="views-1"><a class="header" href="#views-1">Views</a></h1>
<p>Endb provides basic view functionality to support environments
which require a static schema.</p>
<h2 id="create-view"><a class="header" href="#create-view">CREATE VIEW</a></h2>
<p><code>CREATE VIEW</code> creates a non-materialized view based on the query
which follows the <code>AS</code> operator.
Column names are listed in parentheses after the view name.</p>
<pre><code class="language-sql">CREATE VIEW simple_products(name, price) AS SELECT name, ROUND(price) FROM products;
</code></pre>
<p>Alternatively, named columns can each immediately follow queried columns.</p>
<pre><code class="language-sql">CREATE VIEW easy_products AS SELECT name label, ROUND(price) easy_price FROM products;
</code></pre>
<p>NOTE: To modify a view, use <code>DROP VIEW</code> then re-create the view with the desired columns.</p>
<h2 id="drop-view"><a class="header" href="#drop-view">DROP VIEW</a></h2>
<p><code>DROP VIEW</code> deletes a view based on its name.</p>
<pre><code class="language-sql">DROP VIEW easy_products;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assertions"><a class="header" href="#assertions">Assertions</a></h1>
<h2 id="create-assertion"><a class="header" href="#create-assertion">CREATE ASSERTION</a></h2>
<p>Creates a checked, deferred assertion which executes on commit
for inserts and updates.
Although <code>CREATE ASSERTION</code> (normally) refers to the table
it is asserting on, that table need not exist for the assertion to be created.</p>
<h3 id="type-constraint"><a class="header" href="#type-constraint">Type Constraint</a></h3>
<pre><code class="language-sql">CREATE ASSERTION string_email CHECK (NOT EXISTS (SELECT * FROM users WHERE TYPEOF(email) != 'text'));
INSERT INTO users {name: 'Steven', email: 123};
</code></pre>
<h3 id="unique-constraint"><a class="header" href="#unique-constraint">Unique Constraint</a></h3>
<p>There are a number of possible ways to create the equivalent of a <code>UNIQUE</code> constraint,
as found in schema-on-write databases.
One sensible approach is given below.</p>
<pre><code class="language-sql">CREATE ASSERTION unique_email CHECK (1 &gt;= (SELECT MAX(c.cnt) FROM (SELECT COUNT(*) AS cnt FROM users GROUP BY email) AS c));
INSERT INTO users {name: 'Steven', 's@endatabas.com'};
INSERT INTO users {name: 'Sarah', 's@endatabas.com'};
</code></pre>
<h3 id="not-null-constraint"><a class="header" href="#not-null-constraint">Not Null Constraint</a></h3>
<p>There are multiple possible meanings to &quot;not null&quot; columns in Endb:
Columns can be strictly checked for literal <code>NULL</code> in the value position.
Rows can be forbidden from eliding a column (a missing value).
Both literal <code>NULL</code> and elided columns can both be prevented.</p>
<p>This example checks for literal <code>NULL</code> only:</p>
<pre><code class="language-sql">CREATE ASSERTION notnull_email CHECK (NOT EXISTS (SELECT * FROM users WHERE email IS NULL));
INSERT INTO users {name: 'Tian Tian', email: NULL}; -- check fails
INSERT INTO users {name: 'Tian Tian'}; -- permitted
</code></pre>
<h2 id="drop-assertion"><a class="header" href="#drop-assertion">DROP ASSERTION</a></h2>
<p>Removes an assertion from the database based on its name.</p>
<pre><code class="language-sql">DROP ASSERTION string_email;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>Reference documentation exists as a detailed perspective on each feature of Endb.
It does not need to be read from beginning to end.</p>
<ul>
<li><a href="reference/installation.html">Installation</a></li>
<li><a href="reference/operation.html">Operation</a></li>
<li><a href="reference/monitoring.html">Monitoring</a></li>
<li><a href="reference/http_api.html">HTTP API</a></li>
<li><a href="reference/data_types.html">Data Types</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>At this stage, Endatabas is highly experimental.
We do not push images to Docker Hub often.
We recommend building the local Docker image if you want a recent version.</p>
<p>You only need one of the following options.
If you followed the Quickstart, you already have the Docker Hub version installed.</p>
<h2 id="warning-early-alpha-1"><a class="header" href="#warning-early-alpha-1">Warning: Early Alpha</a></h2>
<p>Endb is still in early alpha.</p>
<p>While in alpha, new versions are not guaranteed to have binary-compatible storage with previous versions.
We encourage you to experiment with Endb but please do not use it in production until a General Availability release.</p>
<h2 id="installing-from-docker-hub"><a class="header" href="#installing-from-docker-hub">Installing from Docker Hub</a></h2>
<p>If you run Docker, you can use the default command below.
<code>--rm</code> cleans up (optional), <code>-p</code> exposes the default <code>endb</code> port,
and <code>-v</code> mounts a local volume so your data persists even if you shut down the Docker image.</p>
<pre><code class="language-sh">mkdir -p endb_data
docker pull endatabas/endb
docker run --rm -p 3803:3803 -v endb_data:/app/endb_data endatabas/endb
</code></pre>
<p>If you run Podman, you'll need to specify the <code>docker.io</code> repo explicitly:</p>
<pre><code class="language-sh">mkdir -p endb_data
podman pull docker.io/endatabas/endb
podman run --rm -p 3803:3803 -v endb_data:/app/endb_data docker.io/endatabas/endb
</code></pre>
<h2 id="installing-from-git-docker"><a class="header" href="#installing-from-git-docker">Installing from Git: Docker</a></h2>
<p>If you want to run <code>endb</code> from the main branch, compile and build the Docker image:</p>
<ul>
<li><a href="https://github.com/endatabas/endb/#building">https://github.com/endatabas/endb/#building</a></li>
<li><a href="https://github.com/endatabas/endb/#docker">https://github.com/endatabas/endb/#docker</a></li>
</ul>
<h2 id="installing-from-git-binary"><a class="header" href="#installing-from-git-binary">Installing from Git: Binary</a></h2>
<p>If you don't want Docker at all, you can compile and run the <code>endb</code> binary:</p>
<ul>
<li><a href="https://github.com/endatabas/endb/#building">https://github.com/endatabas/endb/#building</a></li>
<li><code>./target/endb</code></li>
</ul>
<p>NOTE: If you move the <code>endb</code> binary, be sure to copy <code>libendb.so</code> (Linux)
or <code>libendb.dylib</code> (MacOS) into the same directory.
This is because <code>endb</code> requires <code>libendb</code> to run.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operation"><a class="header" href="#operation">Operation</a></h1>
<p>The <code>endb</code> executable aims to provide self-explanatory help
for direct usage of the binary.</p>
<p>See <a href="reference/monitoring.html">Monitoring</a> for more information about logging,
metrics, and tracing.</p>
<pre><code>$ endb --help
Usage: endb [OPTIONS]

Options:
  -d, --data-directory &lt;DATA_DIRECTORY&gt;  [env: ENDB_DATA_DIRECTORY=] [default: endb_data]
  -h, --help                             Print help
  -V, --version                          Print version

Authentication:
      --username &lt;USERNAME&gt;  [env: ENDB_USERNAME=]
      --password &lt;PASSWORD&gt;  [env: ENDB_PASSWORD=]

Network:
  -p, --port &lt;PORT&gt;                  [env: ENDB_PORT=] [default: 3803]
      --bind-address &lt;BIND_ADDRESS&gt;  [env: ENDB_BIND_ADDRESS=] [default: 0.0.0.0]
      --protocol &lt;PROTOCOL&gt;          [env: ENDB_PROTOCOL=] [default: http] [possible values: http, https]
      --cert-file &lt;CERT_FILE&gt;        [env: ENDB_CERT_FILE=]
      --key-file &lt;KEY_FILE&gt;          [env: ENDB_KEY_FILE=]
</code></pre>
<p>The <code>--cert-file</code> and <code>--key-file</code> options are ignored when <code>--protocol</code> is set to <code>http</code>.
When <code>--protocol</code> is set to <code>https</code>, they are both required.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h1>
<p>Some monitoring options are offered as flags.
Set flags by setting the environment variable to <code>0</code> or <code>1</code>
(ex. <code>ENDB_LOG_ANSI=0</code>).</p>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>By default, <code>endb</code> logs to STDOUT with a log level of <code>info</code>.</p>
<p>Adjust the log level with the <code>ENDB_LOG_LEVEL</code> environment variable.
Valid log levels (in increasing level of verbosity and decreasing level of fatality)
are: <code>fatal</code>, <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code>, <code>trace</code>.</p>
<p>Other flags include:</p>
<ul>
<li><code>ENDB_LOG_ANSI</code> - turns ANSI terminal colour output on or off (on by default)</li>
<li><code>ENDB_LOG_THREAD_IDS</code> - set to enable or disable logging of thread ids (enabled by default)</li>
</ul>
<p>Example:</p>
<pre><code class="language-sh">docker run --rm -e ENDB_LOG_LEVEL=debug -e ENDB_LOG_ANSI=0 -e ENDB_LOG_THREAD_IDS=1 -p 3803:3803 -v demo_data:/app/endb_data docker.io/endatabas/endb:latest
</code></pre>
<h2 id="prometheus"><a class="header" href="#prometheus">Prometheus</a></h2>
<p>A Prometheus endpoint at <code>/metrics</code> is provided via an OpenTelemetry Prometheus Exporter.
This endpoint is enabled by default and OpenTelemetry does not need to be enabled
to access it.
If you Endb instance is running locally, you can view metrics in a browser at
http://localhost:3803/metrics</p>
<p>The Prometheus exporter tracing level defaults to <code>debug</code>.
Set the tracing level with <code>ENDB_TRACING_LEVEL</code>.</p>
<h2 id="opentelemetry"><a class="header" href="#opentelemetry">OpenTelemetry</a></h2>
<p>To enable OpenTelemetry, set the <code>ENDB_TRACING_OTEL</code> flag.</p>
<p>The OpenTelemetry tracing level defaults to <code>debug</code>.
Set the tracing level with <code>ENDB_TRACING_LEVEL</code>.</p>
<h2 id="metrics"><a class="header" href="#metrics">Metrics</a></h2>
<p>Endb exposes a number of metrics to the Prometheus endpoint and OpenTelemetry.
These can be useful in debugging performance of applications which use Endb
as a database.</p>
<h3 id="performance-histogram"><a class="header" href="#performance-histogram">Performance (Histogram)</a></h3>
<ul>
<li><code>query_real_time_duration_seconds</code></li>
<li><code>query_gc_run_time_duration_seconds</code></li>
<li><code>query_consed_bytes</code></li>
</ul>
<h3 id="counters"><a class="header" href="#counters">Counters</a></h3>
<ul>
<li><code>queries_active</code></li>
<li><code>interactive_transactions_active</code></li>
<li><code>buffer_pool_usage_bytes</code></li>
<li><code>dynamic_space_usage_bytes</code></li>
</ul>
<h3 id="monotonic-counters"><a class="header" href="#monotonic-counters">Monotonic Counters</a></h3>
<ul>
<li><code>websocket_message_internal_errors_total</code></li>
<li><code>object_store_read_bytes_total</code></li>
<li><code>object_store_written_bytes_total</code></li>
<li><code>queries_total</code></li>
<li><code>transactions_conflicted_total</code></li>
<li><code>transactions_committed_total</code></li>
<li><code>transactions_prepared_total</code></li>
<li><code>transactions_retried_total</code></li>
<li><code>wal_read_bytes_total</code></li>
<li><code>wal_written_bytes_total</code></li>
</ul>
<h2 id="tracing"><a class="header" href="#tracing">Tracing</a></h2>
<p>Endb exposes a variety of tracing spans to the Prometheus endpoint and OpenTelemetry.
Tracing data is mostly useful if your Endb instance is not performing in the way you expect.</p>
<ul>
<li><code>buffer_pool_eviction</code></li>
<li><code>commit</code></li>
<li><code>compaction</code></li>
<li><code>constraints</code></li>
<li><code>gc</code></li>
<li><code>index</code></li>
<li><code>log_replay</code></li>
<li><code>log_rotation</code></li>
<li><code>object_store_delete</code></li>
<li><code>object_store_get</code></li>
<li><code>object_store_list</code></li>
<li><code>object_store_put</code></li>
<li><code>query</code></li>
<li><code>shutdown</code></li>
<li><code>snapshot</code></li>
<li><code>startup</code></li>
<li><code>wal_append_entry</code></li>
<li><code>wal_read_next_entry</code></li>
<li><code>wal_fsync</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-api"><a class="header" href="#http-api">HTTP API</a></h1>
<p>At this experimental stage, only raw HTTP drivers are available.
Any HTTP client may be used but in the examples below, we'll use <code>curl</code>.</p>
<p>You can send SQL statements to <code>endb</code> over HTTP:</p>
<pre><code class="language-sh">curl -d &quot;INSERT INTO users (name) VALUES ('Tianyu')&quot; -H &quot;Content-Type: application/sql&quot; -X POST http://localhost:3803/sql
curl -d &quot;SELECT * FROM users&quot; -H &quot;Content-Type: application/sql&quot; -X POST http://localhost:3803/sql
</code></pre>
<p>You can send SQL to <code>endb</code> with standard HTTP Query Parameters, Verbs,
Content Types, Accept Headers, and HTTP Basic Authentication.
Each one is outlined below.</p>
<h2 id="http-query-parameters"><a class="header" href="#http-query-parameters">HTTP Query Parameters</a></h2>
<p>The query parameters Endb's HTTP endpoint accepts are:</p>
<ul>
<li><code>q</code> - (q)uery: a SQL query, optionally parameterized</li>
<li><code>p</code> - (p)arameters: named or positional <a href="reference/http_api.html#parameters">parameters</a></li>
<li><code>m</code> - (m)ultiple statements: <a href="reference/http_api.html#bulk-parameters">bulk parameters</a>, used for bulk insert/update</li>
</ul>
<h2 id="http-verbs"><a class="header" href="#http-verbs">HTTP Verbs</a></h2>
<p><code>POST</code> allows explicit Content Types and Accept headers:</p>
<pre><code class="language-sh">curl -d 'SELECT 1' -H &quot;Content-Type: application/sql&quot; -H &quot;Accept: text/csv&quot; -X POST http://localhost:3803/sql
</code></pre>
<p><code>GET</code> allows a single, simple URL.
<code>GET</code> does not permit DML.</p>
<pre><code class="language-sh">curl -X GET &quot;http://localhost:3803/sql?q=SELECT%201&quot;
</code></pre>
<h2 id="content-types"><a class="header" href="#content-types">Content Types</a></h2>
<p>The HTTP <code>Content-Type</code> header is used to specify what
format the client is sending data to Endb.</p>
<h3 id="applicationjson"><a class="header" href="#applicationjson"><code>application/json</code>:</a></h3>
<pre><code class="language-sh">curl -d '{&quot;q&quot;: &quot;SELECT * from products;&quot;}' -H &quot;Content-Type: application/json&quot; -X POST http://localhost:3803/sql
curl -d '{&quot;q&quot;: &quot;SELECT * from products WHERE name = ?;&quot;, &quot;p&quot;: [&quot;Salt&quot;]}' -H &quot;Content-Type: application/json&quot; -X POST http://localhost:3803/sql
curl -d '{&quot;q&quot;: &quot;INSERT INTO products {name: :name};&quot;, &quot;p&quot;: {&quot;name&quot;: &quot;Paprika&quot;}}' -H &quot;Content-Type: application/json&quot; -X POST http://localhost:3803/sql
</code></pre>
<p>NOTE: To enable strongly-typed values, payloads sent with
the <code>application/json</code> content type have values resolved with JSON-LD scalars.
Standard JSON values are a subset of JSON-LD scalars, so data sent as regular
JSON is unaffected by this behaviour.</p>
<h3 id="applicationldjson"><a class="header" href="#applicationldjson"><code>application/ld+json</code></a></h3>
<p>Although values in the <code>application/json</code> content type are resolved using
JSON-LD scalars, you can explicitly specify an <code>application/ld+json</code>
content type to avoid all ambiguity.
See <a href="https://json-ld.org/">JSON-LD</a>.</p>
<pre><code class="language-sh">curl -d '{&quot;q&quot;: &quot;INSERT INTO events {start: :start};&quot;, &quot;p&quot;: {&quot;start&quot;: {&quot;@type&quot;: &quot;xsd:dateTime&quot;, &quot;@value&quot;: &quot;2011-04-09T20:00:00Z&quot;}}}' -H &quot;Content-Type: application/ld+json&quot; -X POST http://localhost:3803/sql
</code></pre>
<h3 id="applicationsql"><a class="header" href="#applicationsql"><code>application/sql</code>:</a></h3>
<pre><code class="language-sh">curl -d 'SELECT 1' -H &quot;Content-Type: application/sql&quot; -X POST http://localhost:3803/sql
</code></pre>
<p>Submit parameters to <code>application/sql</code> by providing form data or query parameters.
Form data and query parameters can be combined, though it is not necessarily recommended.</p>
<pre><code class="language-sql">curl -F q=&quot;INSERT INTO sauces {name: ?, color: ?};&quot; -X POST http://localhost:3803/sql?p=%5B%22ketchup%22%2C%22purple%22%5D
</code></pre>
<h3 id="multipartform-data"><a class="header" href="#multipartform-data"><code>multipart/form-data</code></a></h3>
<pre><code class="language-sh">curl -F q=&quot;SELECT * from products;&quot; -H &quot;Content-Type: multipart/form-data&quot; -X POST http://localhost:3803/sql
curl -F q=&quot;INSERT INTO products {name: ?};&quot; -F p='[&quot;Sriracha&quot;]' -X POST http://localhost:3803/sql
</code></pre>
<p>NOTE: Many HTTP clients (including <code>curl</code>) automatically assume a content type of
<code>multipart/form-data</code> when form fields are provided.
This is true for <code>curl</code> when the <code>-F</code> (<code>--form</code>) argument is used and it has
been elided from further examples.</p>
<h3 id="applicationx-www-form-urlencoded"><a class="header" href="#applicationx-www-form-urlencoded"><code>application/x-www-form-urlencoded</code></a></h3>
<p>Although the other content types are preferable for obvious reasons,
<code>application/x-www-form-urlencoded</code> is offered for completeness.</p>
<pre><code class="language-sh">curl -d 'q=SELECT%20*%20FROM%20products;' -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -X POST http://localhost:3803/sql
</code></pre>
<h2 id="accept-headers"><a class="header" href="#accept-headers">Accept Headers</a></h2>
<p>The HTTP <code>Accept</code> header is used to specify how data is returned to
the Endb client.
The default <code>Accept</code> header content type is <code>application/json</code>.</p>
<h3 id="textcsv"><a class="header" href="#textcsv">text/csv</a></h3>
<p><code>text/csv</code> returns comma-separated rows.
Column order from the <code>SELECT</code> clause is maintained.</p>
<pre><code class="language-sh">curl -d &quot;SELECT * FROM (VALUES (1,'hello'), (2,'csv')) t1&quot; -H &quot;Content-Type: application/sql&quot; -H &quot;Accept: text/csv&quot; -X POST http://localhost:3803/sql
</code></pre>
<p>returns:</p>
<pre><code>&quot;column1&quot;,&quot;column2&quot;
2,&quot;csv&quot;
1,&quot;hello&quot;
</code></pre>
<h3 id="applicationjson-1"><a class="header" href="#applicationjson-1">application/json</a></h3>
<p><code>application/json</code> returns rows as an array of JSON tuples.
Column order from the <code>SELECT</code> clause is maintained.</p>
<pre><code class="language-sh">curl -d &quot;SELECT * FROM (VALUES (1,'hello'), (2,DATE('2023-07-22'))) t1&quot; -H &quot;Content-Type: application/sql&quot; -H &quot;Accept: application/json&quot; -X POST http://localhost:3803/sql
</code></pre>
<p>returns:</p>
<pre><code>[[2,&quot;2023-07-22&quot;],[1,&quot;hello&quot;]]
</code></pre>
<h3 id="applicationx-ndjson"><a class="header" href="#applicationx-ndjson">application/x-ndjson</a></h3>
<p><code>application/x-ndjson</code> returns newline-delimited JSON documents.
Column order from the <code>SELECT</code> clause is <em>not</em> maintained.
JSON documents cannot guarantee column order.</p>
<pre><code class="language-sh">curl -d &quot;SELECT * FROM (VALUES (1,'hello'), (2,DATE('2023-07-22'))) t1&quot; -H &quot;Content-Type: application/sql&quot; -H &quot;Accept: application/x-ndjson&quot; -X POST http://localhost:3803/sql
</code></pre>
<p>returns:</p>
<pre><code class="language-json">{&quot;column1&quot;:2,&quot;column2&quot;:&quot;2023-07-22&quot;}
{&quot;column1&quot;:1,&quot;column2&quot;:&quot;hello&quot;}
</code></pre>
<h3 id="applicationldjson-1"><a class="header" href="#applicationldjson-1">application/ld+json</a></h3>
<p><code>application/ld+json</code> returns documents of strongly-typed (&quot;Linking Data&quot;) JSON records.
Column order from the <code>SELECT</code> clause is <em>not</em> maintained.
JSON documents cannot guarantee column order.</p>
<pre><code class="language-sh">curl -d &quot;SELECT * FROM (VALUES (1,'hello'), (2,DATE('2023-07-22'))) t1&quot; -H &quot;Content-Type: application/sql&quot; -H &quot;Accept: application/ld+json&quot; -X POST http://localhost:3803/sql
</code></pre>
<p>returns:</p>
<pre><code class="language-json">{&quot;@context&quot;:{&quot;xsd&quot;:&quot;http://www.w3.org/2001/XMLSchema#&quot;,&quot;@vocab&quot;:&quot;http://endb.io/&quot;},&quot;@graph&quot;:[{&quot;column1&quot;:2,&quot;column2&quot;:{&quot;@value&quot;:&quot;2023-07-22&quot;,&quot;@type&quot;:&quot;xsd:date&quot;}},{&quot;column1&quot;:1,&quot;column2&quot;:&quot;hello&quot;}]}
</code></pre>
<p>See <a href="https://json-ld.org/">JSON-LD</a>.</p>
<h3 id="applicationvndapachearrowfile"><a class="header" href="#applicationvndapachearrowfile">application/vnd.apache.arrow.file</a></h3>
<p><code>application/vnd.apache.arrow.file</code> returns columnar data as an Apache Arrow file.</p>
<pre><code class="language-sh">curl -d &quot;SELECT * FROM (VALUES (1,'hello'), (2,DATE('2023-07-22'))) t1&quot; -H &quot;Content-Type: application/sql&quot; -H &quot;Accept: application/vnd.apache.arrow.file&quot; -X POST http://localhost:3803/sql --output hello.arrow
</code></pre>
<p>The above command returns a file containing a single <code>RecordBatch</code> in an Apache Arrow file in IPC format.
You can examine the file with functions like
<a href="https://arrow.apache.org/docs/python/ipc.html#writing-and-reading-random-access-files"><code>pyarrow.ipc.open_file</code></a>,
as seen in <a href="https://gist.github.com/deobald/a65ca0f57d66041bf66d41d0509a981f">this gist</a>.</p>
<h3 id="applicationvndapachearrowstream"><a class="header" href="#applicationvndapachearrowstream">application/vnd.apache.arrow.stream</a></h3>
<p><code>application/vnd.apache.arrow.stream</code> returns columnar data as an Apache Arrow stream.</p>
<pre><code class="language-sh">curl -d &quot;SELECT * FROM (VALUES (1,'hello'), (2,DATE('2023-07-22'))) t1&quot; -H &quot;Content-Type: application/sql&quot; -H &quot;Accept: application/vnd.apache.arrow.stream&quot; -X POST http://localhost:3803/sql --output streamed.arrow
</code></pre>
<p>The above command returns a file containing an Apache Arrow IPC stream.
You can examine the file with functions like
<a href="https://arrow.apache.org/docs/python/ipc.html#using-streams"><code>pyarrow.ipc.open_stream</code></a>,
as seen in <a href="https://gist.github.com/deobald/1eeca3a08ca1490f49bb67a0fa31994b">this gist</a>.</p>
<h2 id="http-basic-authentication"><a class="header" href="#http-basic-authentication">HTTP Basic Authentication</a></h2>
<p>Endb supports HTTP Basic Authentication as defined by
<a href="https://datatracker.ietf.org/doc/html/rfc7235">RFC 7235</a>.
Pass <code>--username</code> and <code>--password</code> arguments to the <code>endb</code> binary to force
basic authentication for HTTP connections.</p>
<pre><code class="language-sh">./target/endb --username zig --password zag
</code></pre>
<p>Then, from any HTTP client, provide the username and password combination to
execute queries.</p>
<pre><code class="language-sh">curl --user zig:zag -d &quot;SELECT 'Hello World';&quot; -H &quot;Content-Type: application/sql&quot; -X POST http://localhost:3803/sql
</code></pre>
<p>If the client passes an incorrect username or password, it will receive a
<code>401 Authorization Required</code> HTTP status code as a result, but no body.
Be aware of this to ensure client code is written to detect 401 status codes.</p>
<pre><code class="language-sh">$ curl -i --user zig:wrong -d &quot;SELECT 'Hello World';&quot; -H &quot;Content-Type: application/sql&quot; -X POST http://localhost:3803/sql
HTTP/1.1 401 Authorization Required
</code></pre>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h2>
<p>SQL parameters are available to:</p>
<ul>
<li><code>application/json</code> and <code>application/ld+json</code> as part of the <code>POST</code> body</li>
<li><code>multipart/form-data</code> as form data</li>
<li><code>application/x-www-form-urlencoded</code> as URL query parameters</li>
<li><code>application/sql</code> as form data and/or URL query parameters</li>
</ul>
<p>Parameters can be JSON literals, JSON-LD scalars, or SQL literals.
A JSON-LD scalar always has the form: <code>{&quot;@type&quot;: &quot;xsd:TYPE&quot;, &quot;@value&quot;: &quot;DATA&quot;}</code>.
JSON-LD types are listed under the <a href="reference/data_types.html">Data Types</a> table.</p>
<h3 id="named-parameters"><a class="header" href="#named-parameters">Named Parameters</a></h3>
<p>Named parameters substitute parameter placeholders with the form <code>:param</code>
by the parameter key with the corresponding name.
Named parameters are represented as a JSON object.</p>
<pre><code class="language-sh">curl -d '{&quot;q&quot;: &quot;INSERT INTO products {name: :name, price: :price};&quot;, &quot;p&quot;: {&quot;name&quot;: &quot;Paprika&quot;, &quot;price&quot;: 2.99}}' -H &quot;Content-Type: application/json&quot; -X POST http://localhost:3803/sql
curl -d '{&quot;q&quot;: &quot;INSERT INTO events {start: :start};&quot;, &quot;p&quot;: {&quot;start&quot;: {&quot;@type&quot;: &quot;xsd:dateTime&quot;, &quot;@value&quot;: &quot;2011-04-09T20:00:00Z&quot;}}}' -H &quot;Content-Type: application/ld+json&quot; -X POST http://localhost:3803/sql
curl -F q=&quot;INSERT INTO products {name: :sauce};&quot; -F p='{&quot;sauce&quot;: &quot;Sriracha&quot;}' -X POST http://localhost:3803/sql
</code></pre>
<h3 id="positional-parameters"><a class="header" href="#positional-parameters">Positional Parameters</a></h3>
<p>Positional parameters substitute parameter placeholders with the form <code>?</code>
by the parameter values, in the order they appear.
Positional parameters are respresented as a JSON array.</p>
<pre><code class="language-sh">curl -d '{&quot;q&quot;: &quot;SELECT * from products WHERE name = ? AND price &gt; ?;&quot;, &quot;p&quot;: [&quot;Salt&quot;, 3.99]}' -H &quot;Content-Type: application/json&quot; -X POST http://localhost:3803/sql
curl -d '{&quot;q&quot;: &quot;INSERT INTO events {start: ?};&quot;, &quot;p&quot;: [{&quot;@type&quot;: &quot;xsd:dateTime&quot;, &quot;@value&quot;: &quot;2011-04-09T20:00:00Z&quot;}]}' -H &quot;Content-Type: application/ld+json&quot; -X POST http://localhost:3803/sql
curl -F q=&quot;INSERT INTO products {name: ?};&quot; -F p='[&quot;Sriracha&quot;]' -X POST http://localhost:3803/sql
</code></pre>
<h3 id="bulk-parameters"><a class="header" href="#bulk-parameters">Bulk Parameters</a></h3>
<p>Bulk operations are possible by setting the <code>m</code> flag to <code>true</code>.
Bulk operations are available to both named and positional parameters.
The list of parameters supplied in bulk must be nested in an array.</p>
<pre><code class="language-sh">curl -d '{&quot;q&quot;: &quot;INSERT INTO products {name: :name};&quot;, &quot;p&quot;: [{&quot;name&quot;: &quot;Soda&quot;}, {&quot;name&quot;: &quot;Tonic&quot;}], &quot;m&quot;: true}' -H &quot;Content-Type: application/json&quot; -X POST http://localhost:3803/sql
curl -F q=&quot;INSERT INTO sauces {name: ?, color: ?};&quot; -F p='[[&quot;Mustard&quot;, &quot;Yellow&quot;], [&quot;Ketchup&quot;, &quot;Red&quot;]]' -F m=true -X POST http://localhost:3803/sql
</code></pre>
<h3 id="apache-arrow-file-parameters"><a class="header" href="#apache-arrow-file-parameters">Apache Arrow File Parameters</a></h3>
<p>As it is possible to receive Apache Arrow data from an Endb query,
it is possible to submit Apache Arrow as a statement parameter.
The example below assumes the existence of a a table called <code>names</code>,
which only contains one column (<code>name</code>).
Apache Arrow Streams can also be used as parameters in the same way.</p>
<pre><code class="language-sh"># create a sample Arrow file:
curl -d &quot;SELECT * FROM names;&quot; -H &quot;Content-Type: application/sql&quot; -H &quot;Accept: application/vnd.apache.arrow.file&quot; -X POST http://localhost:3803/sql --output names.arrow
# use the sample Arrow file:
curl -F m=true -F q=&quot;INSERT INTO projects {name: :name};&quot; -F &quot;p=@names.arrow;type=application/vnd.apache.arrow.file&quot; -X POST http://localhost:3803/sql
</code></pre>
<p>NOTE: This feature should be used with caution.
Do not submit arbitrary Arrow files as parameters.
If a malformed Arrow file is submitted, the error message returned
(if any) is unlikely to provide guidance.
Preferably, Arrow files should be created using Endb itself, as in
the example above.
Most users will prefer to use a human-readable file format instead,
such as a JSON variant or static SQL statements.</p>
<h2 id="bulk-insert"><a class="header" href="#bulk-insert">Bulk Insert</a></h2>
<p>Bulk inserts are possible by combining the tools mentioned under <a href="reference/http_api.html#parameters"><em>Parameters</em></a>.</p>
<p>For example, the <a href="reference/../sql/queries.html#objects-lists"><code>OBJECTS</code></a> keyword can insert an
array of object literals.
Note that each object used as a positional parameter must be wrapped in a JSON array,
since there may be more than one positional parameter supplied.
Similarly, each named parameter must be wrapped in an object containing a key of the
corresponding name.</p>
<pre><code class="language-sql">curl -F m=true -F q=&quot;INSERT INTO products OBJECTS ?&quot; -F p=&quot;[[{name: 'jam'}], [{name: 'butter'}]]&quot; -X POST http://localhost:3803/sql
curl -F m=true -F q=&quot;INSERT INTO products OBJECTS :product&quot; -F p=&quot;[{product: {name: 'jelly'}}, {product: {name: 'ghee'}}]&quot; -X POST http://localhost:3803/sql
</code></pre>
<h2 id="multiple-statements"><a class="header" href="#multiple-statements">Multiple Statements</a></h2>
<p>It is possible to pass multiple SQL statements to Endb by delimiting
them with semicolons.
Parameters will be passed to all statements in order.</p>
<p>Only the result of the last statement is returned to the client.
In the following example, the <code>INSERT</code> will be successful but will not
return a result.
The <code>SELECT</code> will return to the client.</p>
<pre><code class="language-sh">curl --form-string q=&quot;INSERT INTO sauces {name: ?, color: ?}; SELECT {namo: ?, colour: ?};&quot; -F p='[&quot;Mustard&quot;, &quot;Yellow&quot;, &quot;Ketchup&quot;, &quot;Red&quot;]' -X POST http://localhost:3803/sql
</code></pre>
<p>NOTE: <code>--form-string</code> is required instead of <code>--form</code> to send semicolon-delimited
statements with <code>curl</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<h2 id="scalars"><a class="header" href="#scalars">Scalars</a></h2>
<p>Endb supports the following native scalar types for now.</p>
<p>JSON-LD values with a type of <code>@json</code> will be returned from Endb as JSON literals, verbatim.
The <code>@type</code> listed in parentheses is for reference purposes only.
JSON literal types are implicit so a <code>@value/@type</code> pair is not returned for a JSON literal.</p>
<div class="table-wrapper"><table><thead><tr><th>SQL</th><th>JSON-LD</th><th>Example Literal</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NULL</code></td><td><code>@json</code></td><td><code>null</code></td><td>Null, nil, undefined, or missing</td></tr>
<tr><td><code>TEXT</code></td><td><code>@json</code> (<code>xsd:string</code>)</td><td><code>&quot;hello&quot;</code></td><td>UTF-8 string</td></tr>
<tr><td><code>BOOLEAN</code></td><td><code>@json</code> (<code>xsd:boolean</code>)</td><td><code>FALSE</code></td><td>8-bit boolean</td></tr>
<tr><td><code>INTEGER</code></td><td><code>@json</code> (<code>xsd:int[eger]</code>)</td><td><code>42</code></td><td>64/128-bit two's complement integer</td></tr>
<tr><td><code>REAL</code></td><td><code>@json</code> (<code>xsd:double</code>)</td><td><code>9007199254740992.123</code></td><td>64-bit IEEE 754 floating point number</td></tr>
<tr><td><code>TIMESTAMP</code></td><td><code>xsd:dateTime</code></td><td><code>2007-01-01T00:00:00</code></td><td>ISO microsecond precision timestamp</td></tr>
<tr><td><code>DATE</code></td><td><code>xsd:date</code></td><td><code>2007-01-01</code></td><td>ISO date</td></tr>
<tr><td><code>TIME</code></td><td><code>xsd:time</code></td><td><code>23:30:00</code></td><td>ISO time</td></tr>
<tr><td><code>INTERVAL</code></td><td><code>xsd:duration</code></td><td><code>PT12H34M56.789S</code></td><td>ISO interval</td></tr>
<tr><td><code>BLOB</code></td><td><code>xsd:base64Binary</code></td><td><code>x'DEADBEEF'</code></td><td>Binary large object</td></tr>
</tbody></table>
</div>
<p><a href="reference/../sql/data_types.html">SQL Data Types</a> are covered in detail in the SQL Reference.</p>
<h2 id="collections"><a class="header" href="#collections">Collections</a></h2>
<div class="table-wrapper"><table><thead><tr><th>SQL</th><th>JSON-LD</th><th>Example Literal</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ARRAY</code></td><td><code>@json</code></td><td><code>[&quot;Joe&quot;, &quot;Dan&quot;, &quot;Dwayne&quot;]</code></td><td>Zero-based array</td></tr>
<tr><td><code>OBJECT</code></td><td><code>@json</code></td><td><code>{n: 3, b: 2023-01-01}</code></td><td>Object, map, dict, document</td></tr>
</tbody></table>
</div>
<h2 id="unsupported-scalar-types"><a class="header" href="#unsupported-scalar-types">Unsupported Scalar Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>SQL</th><th>JSON-LD</th><th>Description</th></tr></thead><tbody>
<tr><td><code>DECIMAL</code></td><td><code>xsd:decimal</code></td><td>Arbitrary precision decimal. Use 2 <code>BIGINT</code>s or <code>VARCHAR</code></td></tr>
<tr><td><code>URI</code></td><td><code>xsd:anyURI</code></td><td>Unsupported. Use <code>VARCHAR</code></td></tr>
<tr><td><code>UUID</code></td><td><code>@json</code> (<code>xsd:string</code>)</td><td>Unsupported. Use <code>VARCHAR</code> or <code>BLOB</code></td></tr>
</tbody></table>
</div>
<p>If you strongly feel you need a native representation of one of these types, email us: <a href="mailto:hello@endatabas.com">hello@endatabas.com</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<ul>
<li><a href="appendix/what.html">What?</a></li>
<li><a href="appendix/why.html">Why?</a></li>
<li><a href="appendix/architecture.html">Architecture</a></li>
<li><a href="appendix/roadmap.html">Roadmap</a></li>
<li><a href="appendix/license.html">License</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-endatabas"><a class="header" href="#what-is-endatabas">What is Endatabas?</a></h1>
<p>From the outside, Endatabas (or <em>Endb</em>) is an open source
SQL document database with full history.</p>
<p>On the inside, this means all records in Endatabas are immutable.
An <code>ERASE</code> statement is provided for compliance with laws and policies like GDPR.
Time-travel is possible, but queries default to &quot;as-of-now&quot;.
(Which is the thing you want 97% of the time.)
Rows are &quot;schema-last&quot; documents and joins can be arbitrary, but queries are written in SQL.
Endb stores data in Apache Arrow: scalars are strongly typed, the on-disk format is columnar, and the execution engine understands rows and columns.
Endb separates storage from compute to provide unlimited disk space.</p>
<p>In Swedish, <em>Endatabas</em> means both &quot;a database&quot; and &quot;<em>one</em> database&quot;.
This One Database Dream is twofold:
Endb hopes to provide
<a href="https://en.wikipedia.org/wiki/Hybrid_transactional/analytical_processing">HTAP</a>,
so a secondary analytics database is not required for most users.
Endb plans to use AI
(<a href="https://www.endatabas.com/bibliography.html#YouTube-Raberg-Px-7TlceM5A">adaptive indexing</a>)
to provide fast OLTP and OLAP queries on cheap, elastic infrastructure.</p>
<h2 id="who-wants-one-database"><a class="header" href="#who-wants-one-database">Who wants One Database?</a></h2>
<p>After years of market research, the complaint of database users is universal:
<em>&quot;I want to stop babysitting the database.&quot;</em>
This can mean many things but they're all expensive and complex.</p>
<p>The database equivalent of
<a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule"><em>Greenspun's 10th Rule</em></a>
might be &quot;any sufficiently complicated backend system contains an ad-hoc,
informally-specified, bug-ridden, slow implementation of half a database.&quot;
This was true for much of the work we did in the 2010s and 2020s.
&quot;Babysitting&quot; is sometimes the energy wasted by repeatedly building and maintaining
ad-hoc databases for ourselves instead of building tools for customers.</p>
<p>Buying data products also requires babysitting.
DBAs babysit Oracle indexes.
Developers babysit Postgres query optimizations.
Data engineers babysit ETL pipelines.
Analysts baybsit Redshift history.
SREs babysit Aurora costs.</p>
<p>Endb can't solve all these problems, but it attempts to be a jack-of-all-trades database that solves as many as it can — for as many people as it can.</p>
<h2 id="when-is-one-database-possible"><a class="header" href="#when-is-one-database-possible">When is One Database possible?</a></h2>
<p>After years of Computer Science research, it's also clear a sea change in database tech is due...
right about now.
(Give or take ten years. Our timing may be off.)</p>
<p>Hellerstein and Stonebraker's <a href="https://www.semanticscholar.org/paper/What-Goes-Around-Comes-Around-By-Michael-Hellerstein/2c701eae4bdc89f18eab1277b9c9a909841b2663"><em>What Goes Around Comes Around</em></a>
remains true, decade after decade, since it was published in 2004.
As always, the relational data model is still king and SQL is still the lingua franca of databases.
Together, they assimilate new rivals every decade or so.
Endatabas tries to stand right at the center of this upcoming collapse of the data toolchain.</p>
<p>If we, as an industry, can drop a decade's vestigial growth in favour of a tighter, simpler solution?
Wonderful.
But what if we could shed a half-century's vestiges?
Perhaps event streams, relations, documents, graphs, temporal data, ETL and CDC can all live under one roof for many businesses.</p>
<p>Let's see.
We're not sure if we can make this work.
But it's exciting to try.</p>
<p>—</p>
<p>One Database: Clean. Simple. Less.</p>
<p>(Read more in <a href="appendix/why.html"><em>Why Endatabas?</em></a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-endatabas"><a class="header" href="#why-endatabas">Why Endatabas?</a></h1>
<p>(Read more in <a href="appendix/what.html"><em>What is Endatabas?</em></a>)</p>
<p>Why did we build Endatabas (aka Endb) at all?
Isn't one of the many (<a href="https://www.dbdb.io">many</a>) existing databases good enough?</p>
<p>Many incumbent databases serve their use cases and markets well.
But the demands placed on databases are growing rapidly.
These demands pull in multiple directions, all at once, and existing technology cannot support them without introducing enormous complexity.
Metamorphosis is required.</p>
<p>Endb takes good ideas and makes them easier to access, while reducing operational headache.
It does not try to be flashy or unnecessarily revolutionary.
Instead, it tries to be simple and familiar on the surface while providing a lot of new power under the covers.</p>
<p>Let's talk about what that means in clear, concrete terms.</p>
<h2 id="what-is-endatabas-anyway"><a class="header" href="#what-is-endatabas-anyway">What is Endatabas, anyway?</a></h2>
<p>The tagline &quot;SQL Document Database With Full History&quot; says a lot, but it doesn't say everything.
Endatabas is, first and foremost, an <em>immutable database</em>.
That's the Full History part.
But storing all your data, forever, has clear implications.</p>
<p>We consider these implications to be the <em>pillars</em> of Endatabas.
In 3D geometry, the legs of a tripod are mutually supportive; as long as all three feet are in contact with the ground, the tripod will not wobble or collapse.
So it is with the pillars.
Each supports and implies the others.
The pillars are as follows:</p>
<ul>
<li>Full History (requires: immutable data and erasure)</li>
<li>Timeline (requires: time-traveling queries)</li>
<li>Separation of Storage from Compute (requires: light and adaptive indexing)</li>
<li>Documents (requires: schemaless tables, &quot;schema-per-row&quot;, arbitrary joins)</li>
<li>Analytics (requires: columnar storage and access)</li>
</ul>
<p>At the top of this five-dimensional structure is SQL, the lingua franca of database queries.
We believe it is the right time to integrate these ideas.
But first let's go back a few decades to see how we got here.</p>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>None of the ideas in Endatabas are new.</p>
<p>George Copeland's <a href="https://www.endatabas.com/references.html#10.1145/800083.802685"><em>What if mass storage were free?</em></a>
asked, back in 1980, what an immutable database might look like.
His prescient vision for a database with full history enjoys the clarity of a researcher at the beginning of the database era.
People have occasionally asked of Endatabas, &quot;why bother retaining all history?&quot;
But this is the wrong question.
The real question is: &quot;why bother destroying data?&quot;
Copeland's answers, &quot;The deletion concept was invented to reuse expensive computer storage.&quot;
The software industry has grown so accustomed to the arbitrary deletion of historical data that we now take destroying data for granted.</p>
<p>Mass storage is not free yet — but it is cheap.
Copeland himself addresses &quot;a more realistic argument: if the cost of mass storage were low enough, then deletion would become undesirable.&quot;
Any system that exploits the separation of storage and compute can enjoy these low costs.</p>
<p>An immutable dataset and a timeline of changing states are two sides of the same coin.
Previous states carry the innate property of time (whether defined by familiar wall clocks or versions or logical clocks).
Jensen and Snodgrass have thoroughly researched time-related database queries.
Much of their work was published <a href="https://www.endatabas.com/bibliography.html#10.1109/69.755613">in the 1990s</a>
and early 2000s.
Storing time, querying across time, time as a value ... these challenging subjects eventually grew to form
<a href="https://www.endatabas.com/bibliography.html#ISO/IEC-19075-2:2021">SQL:2011</a>.
Most SQL databases have struggled to implement SQL:2011.
Incorporating <em>time</em> as a core concept in mutable databases (those which support destructive updates and deletes) amplifies existing complexity.
Time should simplify the database, not complicate it.</p>
<p>Document databases have a more convoluted story.
Attempts at &quot;schemaless&quot;, semi-structured, document, and object databases stretch from
<a href="https://www.endatabas.com/bibliography.html#10.1145/971697.602300">Smalltalk in the 1980s</a>
to <a href="https://en.wikipedia.org/wiki/Object_database#Timeline">C++ in the 1990s</a>
to <a href="https://prevayler.org/">Java</a>
and <a href="https://en.wikipedia.org/wiki/Neo4j">graphs in the 2000s</a>
to <a href="https://en.wikipedia.org/wiki/MongoDB">JSON in the 2010s</a>.
Despite all this, the most successful semi-structured document store, as of 2023, is a Postgres database with JSON columns.
Database users desire flexible storage and querying — but yesterday's weather says they desire SQL more.
Can't we have both?</p>
<p>SQL has four identities, four histories.
There is an SQL of academia, born of
<a href="https://www.endatabas.com/references.html#10.1145/362384.362685">Codd's relational algebra (1970)</a> and
<a href="https://www.endatabas.com/references.html#10.1145/800296.811515">Chamberlin/Boyce SEQUEL (1974)</a>,
grown over decades with research like Snodgrass/Jensen's TSQL2.
Then there is the SQL of industry, the many-tentacled leviathan of IBM, Oracle, and Microsoft:
the SQL sold to businesses and governments, ceaselessly bifurcated into new dialects with each version and implementation.
Between these two rests the SQL of the ISO specification —
unified across 11 published standards, from SQL-86 to SQL:2023, spanning thousands of pages, adhered to by no single database.<sup class="footnote-reference"><a href="#mimer">1</a></sup>
Last, there is colloquial SQL, the language one refers to by the question, &quot;do you know SQL?&quot;
These four threads are intertwined across four decades, making it very difficult to clearly define what is meant by &quot;SQL&quot;, even in very narrow contexts.
Colloquial SQL is of greatest interest to us.
This is the ubiquitous query language any new database must implement to succeed.</p>
<p>Khoshafian and Copeland introduced the <a href="https://www.endatabas.com/bibliography.html#10.1145/318898.318923">Decomposition Storage Model (DSM)</a>
in 1985.
The four decades that followed saw any number of approaches to data analytics.
Most of the time, however, these demanded expensive data acrobatics:
data was piped, streamed, dumped, and copied into denormalized cubes and time-series databases.
As humanity grew out of the batch processing of the 1980s into the always-online society of the 2020s, analytics data became another form of operational data and this pipeline was looped back to users and customers.
Hybrid Transactional/Analytical Processing (HTAP) promises a simpler, natural successor to OLTP and OLAP systems.
For many businesses, the transactional/analytical divide is as arbitrary as destroying data with every state change.</p>
<p>Humanity will arbitrarily destroy data in 2026 because hard disks were expensive in 1986.
Similarly, we will wastefully query data with multiple systems in 2026 because CPUs were slow in 1986.</p>
<h2 id="why-sql"><a class="header" href="#why-sql">Why SQL?</a></h2>
<p>When you approach Endb from a distance, you won't see the pillars at first.
You'll see the structure they support.
This structure also binds the pillars together.
The query language of a database is its glue.
It is the user interface.
It defines the user experience.
It is at once a programming language, a dialogue, an envelope, a protocol.
But a query engine is not divorced from its query language, and so the language choice also informs system design and behaviour.</p>
<p>There are mundane reasons for choosing SQL.
If asked &quot;do you know SQL?&quot; there's a high probability the answer is &quot;yes.&quot;
SQL is the language of data science and third-party tools.
If any sufficiently successful database has to provide SQL access anyway, one may as well start there.</p>
<p>But this is not why we chose SQL.
We believe SQL can be beautiful.</p>
<p>As mentioned in <a href="appendix/why.html#history"><em>History</em></a>, we are primarily concerned with colloquial SQL.
The other threads of SQL are relevant but Endb will never implement the entire SQL specification.
Instead, the Endb SQL dialect unifies the pillars under one strongly-dynamically-typed umbrella, a variation of the SQLite dialect.
SQLite's applications are quite different from those of Endatabas, so Endb SQL is not weakly-typed and Endb types are not a free-for-all.
Instead, Endb internally adopts types from <a href="https://arrow.apache.org/">Apache Arrow</a>, which it uses as a storage medium.</p>
<p>When considering alternatives, there are no direct contenders.
Cypher, Datalog, MongoDB query documents, and other schemaless query languages work well for one database implementation but lack both mindshare and standards.
PartiQL, SQL++, and other NewSQL languages that depart from SQL suffer precisely because they are <em>almost</em> SQL.
One can fantasize about designing a query language from scratch but it's very easy to get wrong and takes decades to build mindshare.
SQL has been through this decades-long gauntlet.</p>
<p>Just as PL/SQL and T-SQL differ, so will Endb SQL from other dialects.
However, colloquial SQL is comparable to colloquial Hindi — at higher levels, it bifurcates into Urdu and Sanskrit but speakers of both lineages understand one another.
<a href="appendix/../tutorial/sql_basics.html">Endb SQL will be familiar</a> to users of other SQL dialects.</p>
<p>With its long, rich history SQL not only has the necessary theoretical underpinnings but the battle scars of technology that lasts.
It sits alongside POSIX, TCP/IP, LISP, C, and the QWERTY keyboard layout.
It will see its centenary.</p>
<h2 id="why-full-history"><a class="header" href="#why-full-history">Why Full History?</a></h2>
<p>Even if we ignore Copeland's dream of mass storage from 1980, it is easy to see why destroying data is harmful.
To destroy data is to destroy facts — to lie about the truth of what happened.</p>
<p>Few modern systems permit the total destruction of data for this obvious reason.
Some choose to create audit tables: <code>users_audits</code>, <code>sales_audits</code>, and so on.
Some choose to log anything and everything.
&quot;It's on disk somewhere.&quot;
It's not uncommon for companies to extract metrics from logs to create invoices and reports, turning a log file into a bespoke immutable database.</p>
<p>Industries which take their data very seriously (banking, healthcare) already store immutable records.
They just do so in a mutable database.
Append-only tables are not new, but they're an order of magnitude easier to work with — for both users and operators — if the database is append-only from the ground up.</p>
<p>These same industries will resist the destruction of data unless absolutely necessary, but they will bend to necessity.
<a href="appendix/../sql/data_manipulation.html#erase">Erasure</a> is concomitant with immutability — we cannot have one without the other.
The existing designs of databases create serious problems for privacy.
<code>DELETE</code>, when overloaded to mean both &quot;save disk space&quot; and &quot;explicitly remove this data&quot;, becomes opaque.
It does not leave any queryable record of the deletion.
Removing data should keep tombstones so it's at least known that some data was removed.</p>
<h2 id="why-a-timeline"><a class="header" href="#why-a-timeline">Why a timeline?</a></h2>
<p>Keeping your data's entire history is the write-side of the equation.
If you didn't care about getting this data back, you could just dump it into an unintelligible pile.
But you not only want your data back, you want to query it in the easiest way possible.</p>
<p>One very sensible way to see and query immutable data is along a timeline.
Endb makes no assumptions about your desire to participate in this timeline.
By default, everything is visible <em>as-of-now</em> but querying the past should feel effortless.</p>
<pre><code class="language-sql">-- without time travel:
SELECT * FROM products;
-- time travel to 2020:
SELECT * FROM products FOR SYSTEM_TIME AS OF 2020-08-25T00:00:00;
</code></pre>
<h2 id="why-separation-of-storage-and-compute"><a class="header" href="#why-separation-of-storage-and-compute">Why Separation of Storage and Compute?</a></h2>
<p>Separating storage from compute is an implementation detail.
AWS customers don't choose Amazon Aurora because they're craving this separation.
Decoupling storage from compute makes scale (both up and down) trivial.
It also introduces the possibility of
<a href="https://assets.amazon.science/dc/2b/4ef2b89649f9a393d37d3e042f4e/amazon-aurora-design-considerations-for-high-throughput-cloud-native-relational-databases.pdf">&quot;reducing network traffic, ... fast crash recovery, failovers to replicas without loss of data, and fault-tolerant, self-healing storage.&quot;</a></p>
<p>This decoupling is concomitant with <a href="https://www.youtube.com/watch?v=Px-7TlceM5A">Light and Adaptive Indexing</a>.
It is undesirable to manually construct expensive indexes for unknown future schemas over (effectively) infinite data.
Instead, we should let machine learning handle this job.</p>
<h2 id="why-documents"><a class="header" href="#why-documents">Why documents?</a></h2>
<p>It can be argued that &quot;why documents?&quot; is really multiple questions:
why schemaless?
why nested data?
why dynamic SQL?</p>
<p>First, the challenges.
It is extremely difficult to force global schema onto every row in a table in an immutable world.
Even if there were a simple mechanism in SQL to alter table schema only for certain durations (there isn't), the database user would still be burdened with querying based on a particular schema at a particular time in the history of the table.
This complexity is compounded by the fact that static schemas have less and less meaning in a temporal world.
Endb introduces <a href="https://docs.endatabas.com/sql/time_queries.html">SQL:2011 time-travel and period predicates</a>.
The difficulty, mentioned earlier, that other databases encounter when introducing SQL:2011 is twofold: dealing with &quot;time&quot; in a world where history can be violently rewritten and managing an unbending schema across time.</p>
<p>Nested data is equally unnatural in incumbent databases.
SQL:99, SQL:2016, SQL:2023 all offer some way of shoehorning nested data into flat tables.
DynamoDB, Couchbase, and MongoDB are the most common document databases but they don't speak SQL.<sup class="footnote-reference"><a href="#xquery">2</a></sup>
Not only will no one ever decompose relational data into 6NF, it is unlikely we'll ever see a return to the classic BCNF of business entity-relationship diagrams.
Nested data is here to stay.
Foreign, embedded JSON (or XML) is little more than a band-aid.
Nested data should be native to SQL queries.</p>
<p>Second, the joys.
Schema-per-row can be incredibly liberating.
Not only does this feel more natural, it embraces the messy truth of the real world.
Schema-on-write can be added later, when the business is ready to lock down what it knows about a domain.
But many use cases <em>demand</em> flexible schemas.
What if this week's project requires downloading huge amounts of semi-structured JSON pricing data from the APIs of competing online stores to compare them?
Endb can handle this case out of the box.
Most databases would require a great deal of manipulation first.</p>
<p>Dynamic SQL is required to support schemaless, nested data — but it also brings its own joys.
When dynamic SQL rests on top of a flexible data model which can ingest any data,
it is capable of exploring nested data and easily constructing arbitrary joins users could normally only construct in a graph database.</p>
<h2 id="why-one-database"><a class="header" href="#why-one-database">Why &quot;One Database&quot;?</a></h2>
<p>It is often the job of analytics databases to record and query all the data of a business, denormalized for speed.
There will always be analytical jobs which require data to be transformed.
But many businesses already allow data scientists, analysts, and even CEOs read-only access to an OLTP replica.</p>
<p><a href="https://www.scattered-thoughts.net/writing/a-shallow-survey-of-olap-and-htap-query-engines/">HTAP is right on the horizon</a>.
Endb hopes to participate in that evolution by making all business data accessible to easy-to-produce, cheap, ephemeral read replicas.</p>
<h2 id="why-commercial-open-source"><a class="header" href="#why-commercial-open-source">Why Commercial Open Source?</a></h2>
<p>We cannot reconcile building and selling a product we would never buy ourselves.</p>
<h2 id="why-now"><a class="header" href="#why-now">Why Now?</a></h2>
<p>All of the pillars outlined above have their own strike-when-the-iron-is-hot moment.
The SQLite we know today began to materialize in 2001.
Amazon S3 was launched in 2006.
MongoDB was first released in 2007.
Immutable data and functional programming reached the mainstream in the 2010s.
Datomic (arguably the first immutable OLTP database) was release in 2012.
Amazon Aurora was released in 2015 and Google's AlloyDB in 2022.
Apache Arrow saw its first release in 2016.
Over the past decade, many financial firms built their own in-house temporal databases.
SQL:2011, SQL:2016, and SQL:2023 were ratified in their respective eponymous years.
HTAP hasn't quite happened yet.
AI-driven indexes haven't quite happened yet.</p>
<p>The moment for something like Endatabas is now... but it is a very long moment.
Endatabas cannot be built in a Postgres-compatible fashion.
Technically, it would be prohibitively expensive to build Endatabas from existing components.
It's time for something new.</p>
<div class="footnote-definition" id="mimer"><sup class="footnote-definition-label">1</sup>
<p>The complete SQL specification is very difficult to implement in full, though <a href="https://developer.mimer.com/features/sql-standard/">Mimer likely comes closest to this goal</a>.</p>
</div>
<div class="footnote-definition" id="xquery"><sup class="footnote-definition-label">2</sup>
<p>There is XQuery, of course. But most businesses today do not build their nested data storage on XQuery.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<h2 id="immutable-1"><a class="header" href="#immutable-1">Immutable</a></h2>
<p>All records in Endatabas are immutable.
Historical data is not lost when an <code>UPDATE</code> or <code>DELETE</code> statement is executed.
You can think of <code>endb</code> as one giant log of transactions
with fast queries made possible by <a href="appendix/architecture.html#adaptive-indexing">adaptive indexing</a>.</p>
<h2 id="erasure"><a class="header" href="#erasure">Erasure</a></h2>
<p>The only time data in Endatabas is <em>truly</em> deleted is with the <code>ERASE</code> statement.
This is used for user safety and compliance with laws like GDPR.</p>
<h2 id="dynamic-sql"><a class="header" href="#dynamic-sql">Dynamic SQL</a></h2>
<p>Both the heart and &quot;UI&quot; of Endatabas is a dynamic SQL engine which natively understands strongly-typed,
semi-structured rows (documents).
Here is an example to illustrate what that means:</p>
<pre><code class="language-sql">INSERT INTO stores {brand: &quot;Alonzo's Analog Synthesizers&quot;,
                    addresses: [{city: &quot;New Jersey&quot;,
                                 country: &quot;United States&quot;,
                                 opened: 1929-09-01},
                                {city: &quot;Göttingen&quot;,
                                 country: &quot;Germany&quot;,
                                 opened: 1928-09-01}]};

-- recursive query of ISO dates from the nested document:
SELECT addresses..opened FROM stores;
</code></pre>
<p>Endb SQL bases its core SQL dialect on SQLite.
It also draws inspiration from SQL:99, SQL:2011, SQL:2016, and SQL:2023.
Read more in our <a href="https://www.endatabas.com/bibliography.html">bibliography</a>.</p>
<h2 id="columnar-hybrid-transactional-analytic-processing-htap"><a class="header" href="#columnar-hybrid-transactional-analytic-processing-htap">Columnar: Hybrid Transactional Analytic Processing (HTAP)</a></h2>
<p>Endatabas stores and processes data as columns.
Endb's columnar storage is built on <a href="https://arrow.apache.org/docs/format/Columnar.html">Apache Arrow</a>.
Endb SQL allows users to retrieve data as documents.
The ultimate goal is for Endatabas to serve many (hybrid) purposes: day-to-day transactions and analytical jobs.</p>
<h2 id="query-execution"><a class="header" href="#query-execution">Query Execution</a></h2>
<p>Queries are <a href="https://github.com/endatabas/endb/blob/main/src/sql/compiler.lisp">compiled to Common Lisp</a>
and use hash joins.
Join ordering is done heuristically, by base table size.
Correlated queries are memoized by building indexes in-memory during query execution.</p>
<h1 id="future"><a class="header" href="#future">Future</a></h1>
<p>More detailed information about the future of Endb can be found in <a href="appendix/roadmap.html">the roadmap</a>.</p>
<h2 id="columnar-olap-result-sets"><a class="header" href="#columnar-olap-result-sets">Columnar (OLAP) result sets</a></h2>
<p>Endb does not yet support columnar data returned directly to the user.</p>
<h2 id="cloud-separation-of-storage-from-compute"><a class="header" href="#cloud-separation-of-storage-from-compute">Cloud: Separation of Storage from Compute</a></h2>
<p>If you're not sure what this is, think Amazon Aurora, Google AlloyDB, and Neon.
Compute nodes are the classic database (Postgres, MongoDB, etc.) — in an immutable world, these are just caches.
Storage is elastic object or blob storage (S3, Azure Blobs, etc.).</p>
<p>Endatabas is built to live in the clouds, alongside infinite disk.</p>
<p>Although the groundwork for separating storage from compute exists in Endb today,
elastic storage backends are not yet implemented.</p>
<h2 id="adaptive-indexing"><a class="header" href="#adaptive-indexing">Adaptive Indexing</a></h2>
<p>For more information on light and adaptive indexing, you can watch Håkan's talk from 2022:
<a href="https://www.youtube.com/watch?v=Px-7TlceM5A">&quot;Light and Adaptive Indexing for Immutable Databases&quot;</a></p>
<p>Endb does not yet support adaptive indexing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<p>In the near-term (Q3 2023), we expect to solidify the Endatabas SQL dialect
so early users can get a taste of what it feels like to use it.</p>
<p>You can read our high-level <a href="https://github.com/endatabas/endb/blob/main/ROADMAP.md">roadmap on GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">License</a></h1>
<p>All Endatabas code is Copyright Håkan Råberg and licensed
<a href="https://github.com/endatabas/endb/blob/main/LICENSE">GNU Affero General Public License v3.0</a>,
unless otherwise specified.</p>
<p>To contribute to Endatabas, please refer to
<a href="https://github.com/endatabas/endb/blob/main/CONTRIBUTING.md"><code>CONTRIBUTING</code></a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
